// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robotics.gazebotransport.CoSimMsgs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "robotics.gazebotransport.CoSimMsgs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace robotics {
namespace gazebotransport {

namespace {

const ::google::protobuf::Descriptor* Time_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Time_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketHeader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Packet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Packet_reflection_ = NULL;
struct PacketOneofInstance {
  int status_;
  const ::robotics::gazebotransport::StepSimulation* step_simulation_;
  const ::robotics::gazebotransport::ResetSimulation* reset_simulation_;
  const ::robotics::gazebotransport::Image* image_;
  const ::robotics::gazebotransport::RequestImage* request_image_;
  const ::robotics::gazebotransport::RequestCoSim* request_cosim_;
  const ::robotics::gazebotransport::StopCoSim* stop_cosim_;
  const ::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
  const ::robotics::gazebotransport::Pose* pose_;
  const ::robotics::gazebotransport::StopSimulation* stop_simulation_;
  const ::robotics::gazebotransport::LaserData* laser_data_;
  const ::robotics::gazebotransport::RequestLaser* request_laser_;
  const ::robotics::gazebotransport::ImuData* imu_data_;
  const ::robotics::gazebotransport::RequestImu* request_imu_;
  const ::robotics::gazebotransport::SubscribeImage* subscribe_image_;
  const ::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
  const ::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
  const ::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
  const ::robotics::gazebotransport::GetPose* get_pose_;
  const ::robotics::gazebotransport::GetTopicList* get_topic_list_;
  const ::robotics::gazebotransport::TopicList* topic_list_;
  const ::robotics::gazebotransport::GetModelInfo* get_model_info_;
  const ::robotics::gazebotransport::ModelInfo* model_info_;
  const ::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
  const ::robotics::gazebotransport::MaxStepSize* max_step_size_;
}* Packet_default_oneof_instance_ = NULL;
const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StepSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StepSimulation_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetSimulation_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestImage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestImage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestCoSim_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestCoSim_reflection_ = NULL;
const ::google::protobuf::Descriptor* StopCoSim_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StopCoSim_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetGroundTruthWorldPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetGroundTruthWorldPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* Quaternion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Quaternion_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pose_reflection_ = NULL;
const ::google::protobuf::Descriptor* StopSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StopSimulation_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaserData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaserData_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestLaser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestLaser_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImuData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImuData_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestImu_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestImu_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeImage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeImage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeLaser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeLaser_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeImu_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeImu_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplyLinkWrench_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplyLinkWrench_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplyJointTorque_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplyJointTorque_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetTopicList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetTopicList_reflection_ = NULL;
const ::google::protobuf::Descriptor* TopicList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TopicList_reflection_ = NULL;
const ::google::protobuf::Descriptor* TopicList_TopicInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TopicList_TopicInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetModelInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetModelInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_LINKS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_LINKS_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_JOINTS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_JOINTS_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_Model_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_Model_reflection_ = NULL;
const ::google::protobuf::Descriptor* MaxStepSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MaxStepSize_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "robotics.gazebotransport.CoSimMsgs.proto");
  GOOGLE_CHECK(file != NULL);
  Time_descriptor_ = file->message_type(0);
  static const int Time_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, nano_seconds_),
  };
  Time_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Time_descriptor_,
      Time::default_instance_,
      Time_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _has_bits_[0]),
      -1,
      -1,
      sizeof(Time),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _internal_metadata_),
      -1);
  PacketHeader_descriptor_ = file->message_type(1);
  static const int PacketHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, time_stamp_),
  };
  PacketHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PacketHeader_descriptor_,
      PacketHeader::default_instance_,
      PacketHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(PacketHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, _internal_metadata_),
      -1);
  PacketHeader_MsgID_descriptor_ = PacketHeader_descriptor_->enum_type(0);
  Packet_descriptor_ = file->message_type(2);
  static const int Packet_offsets_[27] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, header_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, status_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, step_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, reset_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_cosim_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, stop_cosim_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_ground_truth_world_pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, stop_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, laser_data_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_laser_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, imu_data_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_imu_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_laser_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_imu_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, apply_joint_torque_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_topic_list_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, topic_list_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_model_info_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, model_info_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, apply_link_wrench_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, max_step_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, payload_),
  };
  Packet_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Packet_descriptor_,
      Packet::default_instance_,
      Packet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _has_bits_[0]),
      -1,
      -1,
      Packet_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _oneof_case_[0]),
      sizeof(Packet),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _internal_metadata_),
      -1);
  Packet_CoSimError_descriptor_ = Packet_descriptor_->enum_type(0);
  StepSimulation_descriptor_ = file->message_type(3);
  static const int StepSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, num_steps_),
  };
  StepSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StepSimulation_descriptor_,
      StepSimulation::default_instance_,
      StepSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(StepSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, _internal_metadata_),
      -1);
  ResetSimulation_descriptor_ = file->message_type(4);
  static const int ResetSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, behavior_),
  };
  ResetSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResetSimulation_descriptor_,
      ResetSimulation::default_instance_,
      ResetSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResetSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, _internal_metadata_),
      -1);
  ResetSimulation_ResetBehavior_descriptor_ = ResetSimulation_descriptor_->enum_type(0);
  Image_descriptor_ = file->message_type(5);
  static const int Image_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_type_),
  };
  Image_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      -1,
      -1,
      sizeof(Image),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _internal_metadata_),
      -1);
  RequestImage_descriptor_ = file->message_type(6);
  static const int RequestImage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, topic_name_),
  };
  RequestImage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestImage_descriptor_,
      RequestImage::default_instance_,
      RequestImage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestImage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, _internal_metadata_),
      -1);
  RequestCoSim_descriptor_ = file->message_type(7);
  static const int RequestCoSim_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, client_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, duration_),
  };
  RequestCoSim_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestCoSim_descriptor_,
      RequestCoSim::default_instance_,
      RequestCoSim_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestCoSim),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, _internal_metadata_),
      -1);
  StopCoSim_descriptor_ = file->message_type(8);
  static const int StopCoSim_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, client_id_),
  };
  StopCoSim_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StopCoSim_descriptor_,
      StopCoSim::default_instance_,
      StopCoSim_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, _has_bits_[0]),
      -1,
      -1,
      sizeof(StopCoSim),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, _internal_metadata_),
      -1);
  GetGroundTruthWorldPose_descriptor_ = file->message_type(9);
  static const int GetGroundTruthWorldPose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, link_name_),
  };
  GetGroundTruthWorldPose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetGroundTruthWorldPose_descriptor_,
      GetGroundTruthWorldPose::default_instance_,
      GetGroundTruthWorldPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetGroundTruthWorldPose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, _internal_metadata_),
      -1);
  Point_descriptor_ = file->message_type(10);
  static const int Point_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, z_),
  };
  Point_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Point_descriptor_,
      Point::default_instance_,
      Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _has_bits_[0]),
      -1,
      -1,
      sizeof(Point),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _internal_metadata_),
      -1);
  Quaternion_descriptor_ = file->message_type(11);
  static const int Quaternion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, w_),
  };
  Quaternion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Quaternion_descriptor_,
      Quaternion::default_instance_,
      Quaternion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _has_bits_[0]),
      -1,
      -1,
      sizeof(Quaternion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _internal_metadata_),
      -1);
  Pose_descriptor_ = file->message_type(12);
  static const int Pose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, orientation_),
  };
  Pose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pose_descriptor_,
      Pose::default_instance_,
      Pose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _has_bits_[0]),
      -1,
      -1,
      sizeof(Pose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _internal_metadata_),
      -1);
  StopSimulation_descriptor_ = file->message_type(13);
  static const int StopSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, stop_scene_),
  };
  StopSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StopSimulation_descriptor_,
      StopSimulation::default_instance_,
      StopSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(StopSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, _internal_metadata_),
      -1);
  LaserData_descriptor_ = file->message_type(14);
  static const int LaserData_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, intensities_),
  };
  LaserData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaserData_descriptor_,
      LaserData::default_instance_,
      LaserData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaserData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, _internal_metadata_),
      -1);
  RequestLaser_descriptor_ = file->message_type(15);
  static const int RequestLaser_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, topic_name_),
  };
  RequestLaser_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestLaser_descriptor_,
      RequestLaser::default_instance_,
      RequestLaser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestLaser),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, _internal_metadata_),
      -1);
  ImuData_descriptor_ = file->message_type(16);
  static const int ImuData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, linear_acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, orientation_),
  };
  ImuData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ImuData_descriptor_,
      ImuData::default_instance_,
      ImuData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, _has_bits_[0]),
      -1,
      -1,
      sizeof(ImuData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, _internal_metadata_),
      -1);
  RequestImu_descriptor_ = file->message_type(17);
  static const int RequestImu_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, topic_name_),
  };
  RequestImu_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestImu_descriptor_,
      RequestImu::default_instance_,
      RequestImu_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestImu),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, _internal_metadata_),
      -1);
  SubscribeImage_descriptor_ = file->message_type(18);
  static const int SubscribeImage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, topic_name_),
  };
  SubscribeImage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeImage_descriptor_,
      SubscribeImage::default_instance_,
      SubscribeImage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeImage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, _internal_metadata_),
      -1);
  SubscribeLaser_descriptor_ = file->message_type(19);
  static const int SubscribeLaser_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, topic_name_),
  };
  SubscribeLaser_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeLaser_descriptor_,
      SubscribeLaser::default_instance_,
      SubscribeLaser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeLaser),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, _internal_metadata_),
      -1);
  SubscribeImu_descriptor_ = file->message_type(20);
  static const int SubscribeImu_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, topic_name_),
  };
  SubscribeImu_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeImu_descriptor_,
      SubscribeImu::default_instance_,
      SubscribeImu_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeImu),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, _internal_metadata_),
      -1);
  ApplyLinkWrench_descriptor_ = file->message_type(21);
  static const int ApplyLinkWrench_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, force_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, torque_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, tx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, ty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, tz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, duration_),
  };
  ApplyLinkWrench_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ApplyLinkWrench_descriptor_,
      ApplyLinkWrench::default_instance_,
      ApplyLinkWrench_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, _has_bits_[0]),
      -1,
      -1,
      sizeof(ApplyLinkWrench),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, _internal_metadata_),
      -1);
  ApplyJointTorque_descriptor_ = file->message_type(22);
  static const int ApplyJointTorque_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, joint_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, effort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, duration_),
  };
  ApplyJointTorque_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ApplyJointTorque_descriptor_,
      ApplyJointTorque::default_instance_,
      ApplyJointTorque_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, _has_bits_[0]),
      -1,
      -1,
      sizeof(ApplyJointTorque),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, _internal_metadata_),
      -1);
  GetPose_descriptor_ = file->message_type(23);
  static const int GetPose_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, model_name_),
  };
  GetPose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetPose_descriptor_,
      GetPose::default_instance_,
      GetPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetPose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, _internal_metadata_),
      -1);
  GetTopicList_descriptor_ = file->message_type(24);
  static const int GetTopicList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, topic_name_),
  };
  GetTopicList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetTopicList_descriptor_,
      GetTopicList::default_instance_,
      GetTopicList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetTopicList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, _internal_metadata_),
      -1);
  TopicList_descriptor_ = file->message_type(25);
  static const int TopicList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, data_),
  };
  TopicList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TopicList_descriptor_,
      TopicList::default_instance_,
      TopicList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, _has_bits_[0]),
      -1,
      -1,
      sizeof(TopicList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, _internal_metadata_),
      -1);
  TopicList_TopicInfo_descriptor_ = TopicList_descriptor_->nested_type(0);
  static const int TopicList_TopicInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, type_),
  };
  TopicList_TopicInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TopicList_TopicInfo_descriptor_,
      TopicList_TopicInfo::default_instance_,
      TopicList_TopicInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TopicList_TopicInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, _internal_metadata_),
      -1);
  GetModelInfo_descriptor_ = file->message_type(26);
  static const int GetModelInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, topic_name_),
  };
  GetModelInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetModelInfo_descriptor_,
      GetModelInfo::default_instance_,
      GetModelInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetModelInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, _internal_metadata_),
      -1);
  ModelInfo_descriptor_ = file->message_type(27);
  static const int ModelInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, model_data_),
  };
  ModelInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_descriptor_,
      ModelInfo::default_instance_,
      ModelInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, _internal_metadata_),
      -1);
  ModelInfo_LINKS_descriptor_ = ModelInfo_descriptor_->nested_type(0);
  static const int ModelInfo_LINKS_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, link_name_),
  };
  ModelInfo_LINKS_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_LINKS_descriptor_,
      ModelInfo_LINKS::default_instance_,
      ModelInfo_LINKS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_LINKS),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, _internal_metadata_),
      -1);
  ModelInfo_JOINTS_descriptor_ = ModelInfo_descriptor_->nested_type(1);
  static const int ModelInfo_JOINTS_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, joint_name_),
  };
  ModelInfo_JOINTS_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_JOINTS_descriptor_,
      ModelInfo_JOINTS::default_instance_,
      ModelInfo_JOINTS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_JOINTS),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, _internal_metadata_),
      -1);
  ModelInfo_Model_descriptor_ = ModelInfo_descriptor_->nested_type(2);
  static const int ModelInfo_Model_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, links_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, joints_),
  };
  ModelInfo_Model_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_Model_descriptor_,
      ModelInfo_Model::default_instance_,
      ModelInfo_Model_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_Model),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, _internal_metadata_),
      -1);
  MaxStepSize_descriptor_ = file->message_type(28);
  static const int MaxStepSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, size_),
  };
  MaxStepSize_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MaxStepSize_descriptor_,
      MaxStepSize::default_instance_,
      MaxStepSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, _has_bits_[0]),
      -1,
      -1,
      sizeof(MaxStepSize),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, _internal_metadata_),
      -1);
  MaxStepSize_TYPE_descriptor_ = MaxStepSize_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Time_descriptor_, &Time::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PacketHeader_descriptor_, &PacketHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Packet_descriptor_, &Packet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StepSimulation_descriptor_, &StepSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResetSimulation_descriptor_, &ResetSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestImage_descriptor_, &RequestImage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestCoSim_descriptor_, &RequestCoSim::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StopCoSim_descriptor_, &StopCoSim::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetGroundTruthWorldPose_descriptor_, &GetGroundTruthWorldPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Point_descriptor_, &Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Quaternion_descriptor_, &Quaternion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pose_descriptor_, &Pose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StopSimulation_descriptor_, &StopSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaserData_descriptor_, &LaserData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestLaser_descriptor_, &RequestLaser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ImuData_descriptor_, &ImuData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestImu_descriptor_, &RequestImu::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeImage_descriptor_, &SubscribeImage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeLaser_descriptor_, &SubscribeLaser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeImu_descriptor_, &SubscribeImu::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ApplyLinkWrench_descriptor_, &ApplyLinkWrench::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ApplyJointTorque_descriptor_, &ApplyJointTorque::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetPose_descriptor_, &GetPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetTopicList_descriptor_, &GetTopicList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TopicList_descriptor_, &TopicList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TopicList_TopicInfo_descriptor_, &TopicList_TopicInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetModelInfo_descriptor_, &GetModelInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_descriptor_, &ModelInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_LINKS_descriptor_, &ModelInfo_LINKS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_JOINTS_descriptor_, &ModelInfo_JOINTS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_Model_descriptor_, &ModelInfo_Model::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MaxStepSize_descriptor_, &MaxStepSize::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  delete Time::default_instance_;
  delete Time_reflection_;
  delete PacketHeader::default_instance_;
  delete PacketHeader_reflection_;
  delete Packet::default_instance_;
  delete Packet_default_oneof_instance_;
  delete Packet_reflection_;
  delete StepSimulation::default_instance_;
  delete StepSimulation_reflection_;
  delete ResetSimulation::default_instance_;
  delete ResetSimulation_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete RequestImage::default_instance_;
  delete RequestImage_reflection_;
  delete RequestCoSim::default_instance_;
  delete RequestCoSim_reflection_;
  delete StopCoSim::default_instance_;
  delete StopCoSim_reflection_;
  delete GetGroundTruthWorldPose::default_instance_;
  delete GetGroundTruthWorldPose_reflection_;
  delete Point::default_instance_;
  delete Point_reflection_;
  delete Quaternion::default_instance_;
  delete Quaternion_reflection_;
  delete Pose::default_instance_;
  delete Pose_reflection_;
  delete StopSimulation::default_instance_;
  delete StopSimulation_reflection_;
  delete LaserData::default_instance_;
  delete LaserData_reflection_;
  delete RequestLaser::default_instance_;
  delete RequestLaser_reflection_;
  delete ImuData::default_instance_;
  delete ImuData_reflection_;
  delete RequestImu::default_instance_;
  delete RequestImu_reflection_;
  delete SubscribeImage::default_instance_;
  delete SubscribeImage_reflection_;
  delete SubscribeLaser::default_instance_;
  delete SubscribeLaser_reflection_;
  delete SubscribeImu::default_instance_;
  delete SubscribeImu_reflection_;
  delete ApplyLinkWrench::default_instance_;
  delete ApplyLinkWrench_reflection_;
  delete ApplyJointTorque::default_instance_;
  delete ApplyJointTorque_reflection_;
  delete GetPose::default_instance_;
  delete GetPose_reflection_;
  delete GetTopicList::default_instance_;
  delete GetTopicList_reflection_;
  delete TopicList::default_instance_;
  delete TopicList_reflection_;
  delete TopicList_TopicInfo::default_instance_;
  delete TopicList_TopicInfo_reflection_;
  delete GetModelInfo::default_instance_;
  delete GetModelInfo_reflection_;
  delete ModelInfo::default_instance_;
  delete ModelInfo_reflection_;
  delete ModelInfo_LINKS::default_instance_;
  delete ModelInfo_LINKS_reflection_;
  delete ModelInfo_JOINTS::default_instance_;
  delete ModelInfo_JOINTS_reflection_;
  delete ModelInfo_Model::default_instance_;
  delete ModelInfo_Model_reflection_;
  delete MaxStepSize::default_instance_;
  delete MaxStepSize_reflection_;
}

void protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n(robotics.gazebotransport.CoSimMsgs.pro"
    "to\022\030robotics.gazebotransport\"-\n\004Time\022\017\n\007"
    "seconds\030\001 \002(\004\022\024\n\014nano_seconds\030\002 \002(\004\"\325\004\n\014"
    "PacketHeader\0228\n\002id\030\001 \002(\0162,.robotics.gaze"
    "botransport.PacketHeader.MsgID\0222\n\ntime_s"
    "tamp\030\002 \002(\0132\036.robotics.gazebotransport.Ti"
    "me\"\326\003\n\005MsgID\022\n\n\006STATUS\020\000\022\023\n\017STEP_SIMULAT"
    "ION\020\001\022\024\n\020RESET_SIMULATION\020\002\022\t\n\005IMAGE\020\003\022\021"
    "\n\rREQUEST_IMAGE\020\004\022\021\n\rREQUEST_COSIM\020\005\022\016\n\n"
    "STOP_COSIM\020\006\022\037\n\033GET_GROUND_TRUTH_WORLD_P"
    "OSE\020\007\022\010\n\004POSE\020\010\022\023\n\017STOP_SIMULATION\020\t\022\016\n\n"
    "LASER_DATA\020\n\022\021\n\rREQUEST_LASER\020\013\022\014\n\010IMU_D"
    "ATA\020\014\022\017\n\013REQUEST_IMU\020\r\022\023\n\017SUBSCRIBE_IMAG"
    "E\020\016\022\023\n\017SUBSCRIBE_LASER\020\017\022\021\n\rSUBSCRIBE_IM"
    "U\020\020\022\026\n\022APPLY_JOINT_TORQUE\020\021\022\014\n\010GET_POSE\020"
    "\022\022\022\n\016GET_TOPIC_LIST\020\023\022\016\n\nTOPIC_LIST\020\024\022\022\n"
    "\016GET_MODEL_INFO\020\025\022\016\n\nMODEL_INFO\020\026\022\025\n\021APP"
    "LY_LINK_WRENCH\020\027\022\021\n\rMAX_STEP_SIZE\020\030\"\261\020\n\006"
    "Packet\0226\n\006header\030\001 \002(\0132&.robotics.gazebo"
    "transport.PacketHeader\022=\n\006status\030\002 \001(\0162+"
    ".robotics.gazebotransport.Packet.CoSimEr"
    "rorH\000\022C\n\017step_simulation\030\003 \001(\0132(.robotic"
    "s.gazebotransport.StepSimulationH\000\022E\n\020re"
    "set_simulation\030\004 \001(\0132).robotics.gazebotr"
    "ansport.ResetSimulationH\000\0220\n\005image\030\005 \001(\013"
    "2\037.robotics.gazebotransport.ImageH\000\022\?\n\rr"
    "equest_image\030\006 \001(\0132&.robotics.gazebotran"
    "sport.RequestImageH\000\022\?\n\rrequest_cosim\030\007 "
    "\001(\0132&.robotics.gazebotransport.RequestCo"
    "SimH\000\0229\n\nstop_cosim\030\010 \001(\0132#.robotics.gaz"
    "ebotransport.StopCoSimH\000\022X\n\033get_ground_t"
    "ruth_world_pose\030\t \001(\01321.robotics.gazebot"
    "ransport.GetGroundTruthWorldPoseH\000\022.\n\004po"
    "se\030\n \001(\0132\036.robotics.gazebotransport.Pose"
    "H\000\022C\n\017stop_simulation\030\013 \001(\0132(.robotics.g"
    "azebotransport.StopSimulationH\000\0229\n\nlaser"
    "_data\030\014 \001(\0132#.robotics.gazebotransport.L"
    "aserDataH\000\022\?\n\rrequest_laser\030\r \001(\0132&.robo"
    "tics.gazebotransport.RequestLaserH\000\0225\n\010i"
    "mu_data\030\016 \001(\0132!.robotics.gazebotransport"
    ".ImuDataH\000\022;\n\013request_imu\030\017 \001(\0132$.roboti"
    "cs.gazebotransport.RequestImuH\000\022C\n\017subsc"
    "ribe_image\030\020 \001(\0132(.robotics.gazebotransp"
    "ort.SubscribeImageH\000\022C\n\017subscribe_laser\030"
    "\021 \001(\0132(.robotics.gazebotransport.Subscri"
    "beLaserH\000\022\?\n\rsubscribe_imu\030\022 \001(\0132&.robot"
    "ics.gazebotransport.SubscribeImuH\000\022H\n\022ap"
    "ply_joint_torque\030\023 \001(\0132*.robotics.gazebo"
    "transport.ApplyJointTorqueH\000\0225\n\010get_pose"
    "\030\024 \001(\0132!.robotics.gazebotransport.GetPos"
    "eH\000\022@\n\016get_topic_list\030\025 \001(\0132&.robotics.g"
    "azebotransport.GetTopicListH\000\0229\n\ntopic_l"
    "ist\030\026 \001(\0132#.robotics.gazebotransport.Top"
    "icListH\000\022@\n\016get_model_info\030\027 \001(\0132&.robot"
    "ics.gazebotransport.GetModelInfoH\000\0229\n\nmo"
    "del_info\030\030 \001(\0132#.robotics.gazebotranspor"
    "t.ModelInfoH\000\022F\n\021apply_link_wrench\030\031 \001(\013"
    "2).robotics.gazebotransport.ApplyLinkWre"
    "nchH\000\022>\n\rmax_step_size\030\032 \001(\0132%.robotics."
    "gazebotransport.MaxStepSizeH\000\"\234\003\n\nCoSimE"
    "rror\022\010\n\004NONE\020\000\022\017\n\013STEP_FAILED\020\001\022\017\n\013MSG_I"
    "NVALID\020\002\022\021\n\rSOCKET_FAILED\020\003\022\020\n\014RESET_FAI"
    "LED\020\004\022\020\n\014COSIM_FAILED\020\005\022\025\n\021STOP_COSIM_FA"
    "ILED\020\006\022&\n\"GET_GROUND_TRUTH_WORLD_POSE_FA"
    "ILED\020\007\022\033\n\027RESET_TIME_SCENE_FAILED\020\010\022\025\n\021R"
    "ESET_TIME_FAILED\020\t\022\017\n\013STOP_FAILED\020\n\022\026\n\022F"
    "ORCE_TYPE_INVALID\020\013\022\026\n\022MODEL_NAME_INVALI"
    "D\020\014\022\025\n\021LINK_NAME_INVALID\020\r\022\026\n\022JOINT_NAME"
    "_INVALID\020\016\022\026\n\022TOPIC_NAME_INVALID\020\017\022\027\n\023TO"
    "RQUE_TYPE_INVALID\020\020\022\027\n\023MAX_STEP_SIZE_ERR"
    "OR\020\021B\t\n\007payload\"#\n\016StepSimulation\022\021\n\tnum"
    "_steps\030\001 \002(\r\"\227\001\n\017ResetSimulation\022I\n\010beha"
    "vior\030\001 \002(\01627.robotics.gazebotransport.Re"
    "setSimulation.ResetBehavior\"9\n\rResetBeha"
    "vior\022\016\n\nRESET_TIME\020\000\022\030\n\024RESET_TIME_AND_S"
    "CENE\020\001\"G\n\005Image\022\r\n\005width\030\001 \002(\r\022\016\n\006height"
    "\030\002 \002(\r\022\014\n\004data\030\003 \002(\014\022\021\n\tdata_type\030\004 \002(\t\""
    "\"\n\014RequestImage\022\022\n\ntopic_name\030\001 \002(\t\"3\n\014R"
    "equestCoSim\022\021\n\tclient_id\030\001 \002(\t\022\020\n\010durati"
    "on\030\002 \002(\001\"\036\n\tStopCoSim\022\021\n\tclient_id\030\001 \002(\t"
    "\"@\n\027GetGroundTruthWorldPose\022\022\n\nmodel_nam"
    "e\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\"(\n\005Point\022\t\n\001x"
    "\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"8\n\nQuaterni"
    "on\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\022\t\n\001w"
    "\030\004 \002(\001\"t\n\004Pose\0221\n\010position\030\001 \002(\0132\037.robot"
    "ics.gazebotransport.Point\0229\n\013orientation"
    "\030\002 \002(\0132$.robotics.gazebotransport.Quater"
    "nion\"$\n\016StopSimulation\022\022\n\nstop_scene\030\001 \002"
    "(\010\"\363\001\n\tLaserData\022\021\n\tangle_min\030\001 \002(\001\022\021\n\ta"
    "ngle_max\030\002 \002(\001\022\022\n\nangle_step\030\003 \002(\001\022\021\n\tra"
    "nge_min\030\004 \002(\001\022\021\n\trange_max\030\005 \002(\001\022\r\n\005coun"
    "t\030\006 \002(\001\022\032\n\022vertical_angle_min\030\007 \002(\001\022\032\n\022v"
    "ertical_angle_max\030\010 \002(\001\022\033\n\023vertical_angl"
    "e_step\030\t \002(\001\022\r\n\005range\030\n \003(\001\022\023\n\013intensiti"
    "es\030\013 \003(\001\"\"\n\014RequestLaser\022\022\n\ntopic_name\030\001"
    " \002(\t\"\275\001\n\007ImuData\022<\n\023linear_acceleration\030"
    "\001 \002(\0132\037.robotics.gazebotransport.Point\0229"
    "\n\020angular_velocity\030\002 \002(\0132\037.robotics.gaze"
    "botransport.Point\0229\n\013orientation\030\003 \002(\0132$"
    ".robotics.gazebotransport.Quaternion\" \n\n"
    "RequestImu\022\022\n\ntopic_name\030\001 \002(\t\"$\n\016Subscr"
    "ibeImage\022\022\n\ntopic_name\030\001 \002(\t\"$\n\016Subscrib"
    "eLaser\022\022\n\ntopic_name\030\001 \002(\t\"\"\n\014SubscribeI"
    "mu\022\022\n\ntopic_name\030\001 \002(\t\"\333\001\n\017ApplyLinkWren"
    "ch\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_name\030\002 \002("
    "\t\022\022\n\nforce_type\030\003 \002(\t\022\n\n\002fx\030\004 \002(\001\022\n\n\002fy\030"
    "\005 \002(\001\022\n\n\002fz\030\006 \002(\001\022\023\n\013torque_type\030\007 \002(\t\022\n"
    "\n\002tx\030\010 \002(\001\022\n\n\002ty\030\t \002(\001\022\n\n\002tz\030\n \002(\001\0220\n\010du"
    "ration\030\013 \002(\0132\036.robotics.gazebotransport."
    "Time\"\213\001\n\020ApplyJointTorque\022\022\n\nmodel_name\030"
    "\001 \002(\t\022\022\n\njoint_name\030\002 \002(\t\022\r\n\005index\030\003 \002(\r"
    "\022\016\n\006effort\030\004 \002(\001\0220\n\010duration\030\005 \002(\0132\036.rob"
    "otics.gazebotransport.Time\"\035\n\007GetPose\022\022\n"
    "\nmodel_name\030\001 \002(\t\"\"\n\014GetTopicList\022\022\n\ntop"
    "ic_name\030\001 \002(\t\"q\n\tTopicList\022;\n\004data\030\001 \003(\013"
    "2-.robotics.gazebotransport.TopicList.To"
    "picInfo\032\'\n\tTopicInfo\022\014\n\004name\030\001 \002(\t\022\014\n\004ty"
    "pe\030\002 \002(\t\"\"\n\014GetModelInfo\022\022\n\ntopic_name\030\001"
    " \002(\t\"\230\002\n\tModelInfo\022=\n\nmodel_data\030\001 \003(\0132)"
    ".robotics.gazebotransport.ModelInfo.Mode"
    "l\032\032\n\005LINKS\022\021\n\tlink_name\030\001 \003(\t\032\034\n\006JOINTS\022"
    "\022\n\njoint_name\030\001 \003(\t\032\221\001\n\005Model\022\022\n\nmodel_n"
    "ame\030\001 \002(\t\0228\n\005links\030\002 \001(\0132).robotics.gaze"
    "botransport.ModelInfo.LINKS\022:\n\006joints\030\003 "
    "\001(\0132*.robotics.gazebotransport.ModelInfo"
    ".JOINTS\"\203\001\n\013MaxStepSize\0228\n\004type\030\001 \002(\0162*."
    "robotics.gazebotransport.MaxStepSize.TYP"
    "E\022\014\n\004size\030\002 \002(\001\",\n\004TYPE\022\021\n\rSET_STEP_SIZE"
    "\020\000\022\021\n\rGET_STEP_SIZE\020\001", 5141);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "robotics.gazebotransport.CoSimMsgs.proto", &protobuf_RegisterTypes);
  Time::default_instance_ = new Time();
  PacketHeader::default_instance_ = new PacketHeader();
  Packet::default_instance_ = new Packet();
  Packet_default_oneof_instance_ = new PacketOneofInstance();
  StepSimulation::default_instance_ = new StepSimulation();
  ResetSimulation::default_instance_ = new ResetSimulation();
  Image::default_instance_ = new Image();
  RequestImage::default_instance_ = new RequestImage();
  RequestCoSim::default_instance_ = new RequestCoSim();
  StopCoSim::default_instance_ = new StopCoSim();
  GetGroundTruthWorldPose::default_instance_ = new GetGroundTruthWorldPose();
  Point::default_instance_ = new Point();
  Quaternion::default_instance_ = new Quaternion();
  Pose::default_instance_ = new Pose();
  StopSimulation::default_instance_ = new StopSimulation();
  LaserData::default_instance_ = new LaserData();
  RequestLaser::default_instance_ = new RequestLaser();
  ImuData::default_instance_ = new ImuData();
  RequestImu::default_instance_ = new RequestImu();
  SubscribeImage::default_instance_ = new SubscribeImage();
  SubscribeLaser::default_instance_ = new SubscribeLaser();
  SubscribeImu::default_instance_ = new SubscribeImu();
  ApplyLinkWrench::default_instance_ = new ApplyLinkWrench();
  ApplyJointTorque::default_instance_ = new ApplyJointTorque();
  GetPose::default_instance_ = new GetPose();
  GetTopicList::default_instance_ = new GetTopicList();
  TopicList::default_instance_ = new TopicList();
  TopicList_TopicInfo::default_instance_ = new TopicList_TopicInfo();
  GetModelInfo::default_instance_ = new GetModelInfo();
  ModelInfo::default_instance_ = new ModelInfo();
  ModelInfo_LINKS::default_instance_ = new ModelInfo_LINKS();
  ModelInfo_JOINTS::default_instance_ = new ModelInfo_JOINTS();
  ModelInfo_Model::default_instance_ = new ModelInfo_Model();
  MaxStepSize::default_instance_ = new MaxStepSize();
  Time::default_instance_->InitAsDefaultInstance();
  PacketHeader::default_instance_->InitAsDefaultInstance();
  Packet::default_instance_->InitAsDefaultInstance();
  StepSimulation::default_instance_->InitAsDefaultInstance();
  ResetSimulation::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  RequestImage::default_instance_->InitAsDefaultInstance();
  RequestCoSim::default_instance_->InitAsDefaultInstance();
  StopCoSim::default_instance_->InitAsDefaultInstance();
  GetGroundTruthWorldPose::default_instance_->InitAsDefaultInstance();
  Point::default_instance_->InitAsDefaultInstance();
  Quaternion::default_instance_->InitAsDefaultInstance();
  Pose::default_instance_->InitAsDefaultInstance();
  StopSimulation::default_instance_->InitAsDefaultInstance();
  LaserData::default_instance_->InitAsDefaultInstance();
  RequestLaser::default_instance_->InitAsDefaultInstance();
  ImuData::default_instance_->InitAsDefaultInstance();
  RequestImu::default_instance_->InitAsDefaultInstance();
  SubscribeImage::default_instance_->InitAsDefaultInstance();
  SubscribeLaser::default_instance_->InitAsDefaultInstance();
  SubscribeImu::default_instance_->InitAsDefaultInstance();
  ApplyLinkWrench::default_instance_->InitAsDefaultInstance();
  ApplyJointTorque::default_instance_->InitAsDefaultInstance();
  GetPose::default_instance_->InitAsDefaultInstance();
  GetTopicList::default_instance_->InitAsDefaultInstance();
  TopicList::default_instance_->InitAsDefaultInstance();
  TopicList_TopicInfo::default_instance_->InitAsDefaultInstance();
  GetModelInfo::default_instance_->InitAsDefaultInstance();
  ModelInfo::default_instance_->InitAsDefaultInstance();
  ModelInfo_LINKS::default_instance_->InitAsDefaultInstance();
  ModelInfo_JOINTS::default_instance_->InitAsDefaultInstance();
  ModelInfo_Model::default_instance_->InitAsDefaultInstance();
  MaxStepSize::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_robotics_2egazebotransport_2eCoSimMsgs_2eproto {
  StaticDescriptorInitializer_robotics_2egazebotransport_2eCoSimMsgs_2eproto() {
    protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  }
} static_descriptor_initializer_robotics_2egazebotransport_2eCoSimMsgs_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Time::kSecondsFieldNumber;
const int Time::kNanoSecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Time::Time()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Time)
}

void Time::InitAsDefaultInstance() {
}

Time::Time(const Time& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Time)
}

void Time::SharedCtor() {
  _cached_size_ = 0;
  seconds_ = GOOGLE_ULONGLONG(0);
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Time)
  SharedDtor();
}

void Time::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Time::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Time_descriptor_;
}

const Time& Time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Time* Time::default_instance_ = NULL;

Time* Time::New(::google::protobuf::Arena* arena) const {
  Time* n = new Time;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Time::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Time)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Time, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Time*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(seconds_, nano_seconds_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Time)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 seconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_nano_seconds;
        break;
      }

      // required uint64 nano_seconds = 2;
      case 2: {
        if (tag == 16) {
         parse_nano_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nano_seconds_)));
          set_has_nano_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Time)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Time)
  return false;
#undef DO_
}

void Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Time)
  // required uint64 seconds = 1;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->seconds(), output);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->nano_seconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Time)
}

::google::protobuf::uint8* Time::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Time)
  // required uint64 seconds = 1;
  if (has_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->seconds(), target);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->nano_seconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Time)
  return target;
}

int Time::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.Time)
  int total_size = 0;

  if (has_seconds()) {
    // required uint64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->seconds());
  }

  if (has_nano_seconds()) {
    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->nano_seconds());
  }

  return total_size;
}
int Time::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Time)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->seconds());

    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->nano_seconds());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Time::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Time* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Time>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Time)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Time)
    MergeFrom(*source);
  }
}

void Time::MergeFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
    if (from.has_nano_seconds()) {
      set_nano_seconds(from.nano_seconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Time::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Time::CopyFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Time::Swap(Time* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Time::InternalSwap(Time* other) {
  std::swap(seconds_, other->seconds_);
  std::swap(nano_seconds_, other->nano_seconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Time::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Time_descriptor_;
  metadata.reflection = Time_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Time

// required uint64 seconds = 1;
bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void Time::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
 ::google::protobuf::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Time.seconds)
  return seconds_;
}
 void Time::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
bool Time::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Time::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
void Time::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
void Time::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
 ::google::protobuf::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Time.nano_seconds)
  return nano_seconds_;
}
 void Time::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Time.nano_seconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketHeader_MsgID_descriptor_;
}
bool PacketHeader_MsgID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PacketHeader_MsgID PacketHeader::STATUS;
const PacketHeader_MsgID PacketHeader::STEP_SIMULATION;
const PacketHeader_MsgID PacketHeader::RESET_SIMULATION;
const PacketHeader_MsgID PacketHeader::IMAGE;
const PacketHeader_MsgID PacketHeader::REQUEST_IMAGE;
const PacketHeader_MsgID PacketHeader::REQUEST_COSIM;
const PacketHeader_MsgID PacketHeader::STOP_COSIM;
const PacketHeader_MsgID PacketHeader::GET_GROUND_TRUTH_WORLD_POSE;
const PacketHeader_MsgID PacketHeader::POSE;
const PacketHeader_MsgID PacketHeader::STOP_SIMULATION;
const PacketHeader_MsgID PacketHeader::LASER_DATA;
const PacketHeader_MsgID PacketHeader::REQUEST_LASER;
const PacketHeader_MsgID PacketHeader::IMU_DATA;
const PacketHeader_MsgID PacketHeader::REQUEST_IMU;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMAGE;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_LASER;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMU;
const PacketHeader_MsgID PacketHeader::APPLY_JOINT_TORQUE;
const PacketHeader_MsgID PacketHeader::GET_POSE;
const PacketHeader_MsgID PacketHeader::GET_TOPIC_LIST;
const PacketHeader_MsgID PacketHeader::TOPIC_LIST;
const PacketHeader_MsgID PacketHeader::GET_MODEL_INFO;
const PacketHeader_MsgID PacketHeader::MODEL_INFO;
const PacketHeader_MsgID PacketHeader::APPLY_LINK_WRENCH;
const PacketHeader_MsgID PacketHeader::MAX_STEP_SIZE;
const PacketHeader_MsgID PacketHeader::MsgID_MIN;
const PacketHeader_MsgID PacketHeader::MsgID_MAX;
const int PacketHeader::MsgID_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PacketHeader::kIdFieldNumber;
const int PacketHeader::kTimeStampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PacketHeader::PacketHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.PacketHeader)
}

void PacketHeader::InitAsDefaultInstance() {
  time_stamp_ = const_cast< ::robotics::gazebotransport::Time*>(&::robotics::gazebotransport::Time::default_instance());
}

PacketHeader::PacketHeader(const PacketHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.PacketHeader)
}

void PacketHeader::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  time_stamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketHeader::~PacketHeader() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.PacketHeader)
  SharedDtor();
}

void PacketHeader::SharedDtor() {
  if (this != default_instance_) {
    delete time_stamp_;
  }
}

void PacketHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketHeader_descriptor_;
}

const PacketHeader& PacketHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

PacketHeader* PacketHeader::default_instance_ = NULL;

PacketHeader* PacketHeader::New(::google::protobuf::Arena* arena) const {
  PacketHeader* n = new PacketHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PacketHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.PacketHeader)
  if (_has_bits_[0 / 32] & 3u) {
    id_ = 0;
    if (has_time_stamp()) {
      if (time_stamp_ != NULL) time_stamp_->::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PacketHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.PacketHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value)) {
            set_id(static_cast< ::robotics::gazebotransport::PacketHeader_MsgID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_time_stamp;
        break;
      }

      // required .robotics.gazebotransport.Time time_stamp = 2;
      case 2: {
        if (tag == 18) {
         parse_time_stamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time_stamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.PacketHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.PacketHeader)
  return false;
#undef DO_
}

void PacketHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.PacketHeader)
  // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required .robotics.gazebotransport.Time time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->time_stamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.PacketHeader)
}

::google::protobuf::uint8* PacketHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.PacketHeader)
  // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required .robotics.gazebotransport.Time time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->time_stamp_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.PacketHeader)
  return target;
}

int PacketHeader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.PacketHeader)
  int total_size = 0;

  if (has_id()) {
    // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_time_stamp()) {
    // required .robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_stamp_);
  }

  return total_size;
}
int PacketHeader::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.PacketHeader)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required .robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_stamp_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.PacketHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PacketHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PacketHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.PacketHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.PacketHeader)
    MergeFrom(*source);
  }
}

void PacketHeader::MergeFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.PacketHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_time_stamp()) {
      mutable_time_stamp()->::robotics::gazebotransport::Time::MergeFrom(from.time_stamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PacketHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketHeader::CopyFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_time_stamp()) {
    if (!this->time_stamp_->IsInitialized()) return false;
  }
  return true;
}

void PacketHeader::Swap(PacketHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PacketHeader::InternalSwap(PacketHeader* other) {
  std::swap(id_, other->id_);
  std::swap(time_stamp_, other->time_stamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PacketHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketHeader_descriptor_;
  metadata.reflection = PacketHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PacketHeader

// required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
bool PacketHeader::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PacketHeader::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void PacketHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void PacketHeader::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.PacketHeader.id)
  return static_cast< ::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
 void PacketHeader::set_id(::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.PacketHeader.id)
}

// required .robotics.gazebotransport.Time time_stamp = 2;
bool PacketHeader::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PacketHeader::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
void PacketHeader::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != NULL) time_stamp_->::robotics::gazebotransport::Time::Clear();
  clear_has_time_stamp();
}
const ::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_ != NULL ? *time_stamp_ : *default_instance_->time_stamp_;
}
::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == NULL) {
    time_stamp_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_;
}
::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.PacketHeader.time_stamp)
  clear_has_time_stamp();
  ::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
void PacketHeader::set_allocated_time_stamp(::robotics::gazebotransport::Time* time_stamp) {
  delete time_stamp_;
  time_stamp_ = time_stamp;
  if (time_stamp) {
    set_has_time_stamp();
  } else {
    clear_has_time_stamp();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.PacketHeader.time_stamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Packet_CoSimError_descriptor_;
}
bool Packet_CoSimError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Packet_CoSimError Packet::NONE;
const Packet_CoSimError Packet::STEP_FAILED;
const Packet_CoSimError Packet::MSG_INVALID;
const Packet_CoSimError Packet::SOCKET_FAILED;
const Packet_CoSimError Packet::RESET_FAILED;
const Packet_CoSimError Packet::COSIM_FAILED;
const Packet_CoSimError Packet::STOP_COSIM_FAILED;
const Packet_CoSimError Packet::GET_GROUND_TRUTH_WORLD_POSE_FAILED;
const Packet_CoSimError Packet::RESET_TIME_SCENE_FAILED;
const Packet_CoSimError Packet::RESET_TIME_FAILED;
const Packet_CoSimError Packet::STOP_FAILED;
const Packet_CoSimError Packet::FORCE_TYPE_INVALID;
const Packet_CoSimError Packet::MODEL_NAME_INVALID;
const Packet_CoSimError Packet::LINK_NAME_INVALID;
const Packet_CoSimError Packet::JOINT_NAME_INVALID;
const Packet_CoSimError Packet::TOPIC_NAME_INVALID;
const Packet_CoSimError Packet::TORQUE_TYPE_INVALID;
const Packet_CoSimError Packet::MAX_STEP_SIZE_ERROR;
const Packet_CoSimError Packet::CoSimError_MIN;
const Packet_CoSimError Packet::CoSimError_MAX;
const int Packet::CoSimError_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Packet::kHeaderFieldNumber;
const int Packet::kStatusFieldNumber;
const int Packet::kStepSimulationFieldNumber;
const int Packet::kResetSimulationFieldNumber;
const int Packet::kImageFieldNumber;
const int Packet::kRequestImageFieldNumber;
const int Packet::kRequestCosimFieldNumber;
const int Packet::kStopCosimFieldNumber;
const int Packet::kGetGroundTruthWorldPoseFieldNumber;
const int Packet::kPoseFieldNumber;
const int Packet::kStopSimulationFieldNumber;
const int Packet::kLaserDataFieldNumber;
const int Packet::kRequestLaserFieldNumber;
const int Packet::kImuDataFieldNumber;
const int Packet::kRequestImuFieldNumber;
const int Packet::kSubscribeImageFieldNumber;
const int Packet::kSubscribeLaserFieldNumber;
const int Packet::kSubscribeImuFieldNumber;
const int Packet::kApplyJointTorqueFieldNumber;
const int Packet::kGetPoseFieldNumber;
const int Packet::kGetTopicListFieldNumber;
const int Packet::kTopicListFieldNumber;
const int Packet::kGetModelInfoFieldNumber;
const int Packet::kModelInfoFieldNumber;
const int Packet::kApplyLinkWrenchFieldNumber;
const int Packet::kMaxStepSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Packet::Packet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Packet)
}

void Packet::InitAsDefaultInstance() {
  header_ = const_cast< ::robotics::gazebotransport::PacketHeader*>(&::robotics::gazebotransport::PacketHeader::default_instance());
  Packet_default_oneof_instance_->status_ = 0;
  Packet_default_oneof_instance_->step_simulation_ = const_cast< ::robotics::gazebotransport::StepSimulation*>(&::robotics::gazebotransport::StepSimulation::default_instance());
  Packet_default_oneof_instance_->reset_simulation_ = const_cast< ::robotics::gazebotransport::ResetSimulation*>(&::robotics::gazebotransport::ResetSimulation::default_instance());
  Packet_default_oneof_instance_->image_ = const_cast< ::robotics::gazebotransport::Image*>(&::robotics::gazebotransport::Image::default_instance());
  Packet_default_oneof_instance_->request_image_ = const_cast< ::robotics::gazebotransport::RequestImage*>(&::robotics::gazebotransport::RequestImage::default_instance());
  Packet_default_oneof_instance_->request_cosim_ = const_cast< ::robotics::gazebotransport::RequestCoSim*>(&::robotics::gazebotransport::RequestCoSim::default_instance());
  Packet_default_oneof_instance_->stop_cosim_ = const_cast< ::robotics::gazebotransport::StopCoSim*>(&::robotics::gazebotransport::StopCoSim::default_instance());
  Packet_default_oneof_instance_->get_ground_truth_world_pose_ = const_cast< ::robotics::gazebotransport::GetGroundTruthWorldPose*>(&::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance());
  Packet_default_oneof_instance_->pose_ = const_cast< ::robotics::gazebotransport::Pose*>(&::robotics::gazebotransport::Pose::default_instance());
  Packet_default_oneof_instance_->stop_simulation_ = const_cast< ::robotics::gazebotransport::StopSimulation*>(&::robotics::gazebotransport::StopSimulation::default_instance());
  Packet_default_oneof_instance_->laser_data_ = const_cast< ::robotics::gazebotransport::LaserData*>(&::robotics::gazebotransport::LaserData::default_instance());
  Packet_default_oneof_instance_->request_laser_ = const_cast< ::robotics::gazebotransport::RequestLaser*>(&::robotics::gazebotransport::RequestLaser::default_instance());
  Packet_default_oneof_instance_->imu_data_ = const_cast< ::robotics::gazebotransport::ImuData*>(&::robotics::gazebotransport::ImuData::default_instance());
  Packet_default_oneof_instance_->request_imu_ = const_cast< ::robotics::gazebotransport::RequestImu*>(&::robotics::gazebotransport::RequestImu::default_instance());
  Packet_default_oneof_instance_->subscribe_image_ = const_cast< ::robotics::gazebotransport::SubscribeImage*>(&::robotics::gazebotransport::SubscribeImage::default_instance());
  Packet_default_oneof_instance_->subscribe_laser_ = const_cast< ::robotics::gazebotransport::SubscribeLaser*>(&::robotics::gazebotransport::SubscribeLaser::default_instance());
  Packet_default_oneof_instance_->subscribe_imu_ = const_cast< ::robotics::gazebotransport::SubscribeImu*>(&::robotics::gazebotransport::SubscribeImu::default_instance());
  Packet_default_oneof_instance_->apply_joint_torque_ = const_cast< ::robotics::gazebotransport::ApplyJointTorque*>(&::robotics::gazebotransport::ApplyJointTorque::default_instance());
  Packet_default_oneof_instance_->get_pose_ = const_cast< ::robotics::gazebotransport::GetPose*>(&::robotics::gazebotransport::GetPose::default_instance());
  Packet_default_oneof_instance_->get_topic_list_ = const_cast< ::robotics::gazebotransport::GetTopicList*>(&::robotics::gazebotransport::GetTopicList::default_instance());
  Packet_default_oneof_instance_->topic_list_ = const_cast< ::robotics::gazebotransport::TopicList*>(&::robotics::gazebotransport::TopicList::default_instance());
  Packet_default_oneof_instance_->get_model_info_ = const_cast< ::robotics::gazebotransport::GetModelInfo*>(&::robotics::gazebotransport::GetModelInfo::default_instance());
  Packet_default_oneof_instance_->model_info_ = const_cast< ::robotics::gazebotransport::ModelInfo*>(&::robotics::gazebotransport::ModelInfo::default_instance());
  Packet_default_oneof_instance_->apply_link_wrench_ = const_cast< ::robotics::gazebotransport::ApplyLinkWrench*>(&::robotics::gazebotransport::ApplyLinkWrench::default_instance());
  Packet_default_oneof_instance_->max_step_size_ = const_cast< ::robotics::gazebotransport::MaxStepSize*>(&::robotics::gazebotransport::MaxStepSize::default_instance());
}

Packet::Packet(const Packet& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Packet)
}

void Packet::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_payload();
}

Packet::~Packet() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Packet)
  SharedDtor();
}

void Packet::SharedDtor() {
  if (has_payload()) {
    clear_payload();
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void Packet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Packet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Packet_descriptor_;
}

const Packet& Packet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Packet* Packet::default_instance_ = NULL;

Packet* Packet::New(::google::protobuf::Arena* arena) const {
  Packet* n = new Packet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Packet::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:robotics.gazebotransport.Packet)
  switch(payload_case()) {
    case kStatus: {
      // No need to clear
      break;
    }
    case kStepSimulation: {
      delete payload_.step_simulation_;
      break;
    }
    case kResetSimulation: {
      delete payload_.reset_simulation_;
      break;
    }
    case kImage: {
      delete payload_.image_;
      break;
    }
    case kRequestImage: {
      delete payload_.request_image_;
      break;
    }
    case kRequestCosim: {
      delete payload_.request_cosim_;
      break;
    }
    case kStopCosim: {
      delete payload_.stop_cosim_;
      break;
    }
    case kGetGroundTruthWorldPose: {
      delete payload_.get_ground_truth_world_pose_;
      break;
    }
    case kPose: {
      delete payload_.pose_;
      break;
    }
    case kStopSimulation: {
      delete payload_.stop_simulation_;
      break;
    }
    case kLaserData: {
      delete payload_.laser_data_;
      break;
    }
    case kRequestLaser: {
      delete payload_.request_laser_;
      break;
    }
    case kImuData: {
      delete payload_.imu_data_;
      break;
    }
    case kRequestImu: {
      delete payload_.request_imu_;
      break;
    }
    case kSubscribeImage: {
      delete payload_.subscribe_image_;
      break;
    }
    case kSubscribeLaser: {
      delete payload_.subscribe_laser_;
      break;
    }
    case kSubscribeImu: {
      delete payload_.subscribe_imu_;
      break;
    }
    case kApplyJointTorque: {
      delete payload_.apply_joint_torque_;
      break;
    }
    case kGetPose: {
      delete payload_.get_pose_;
      break;
    }
    case kGetTopicList: {
      delete payload_.get_topic_list_;
      break;
    }
    case kTopicList: {
      delete payload_.topic_list_;
      break;
    }
    case kGetModelInfo: {
      delete payload_.get_model_info_;
      break;
    }
    case kModelInfo: {
      delete payload_.model_info_;
      break;
    }
    case kApplyLinkWrench: {
      delete payload_.apply_link_wrench_;
      break;
    }
    case kMaxStepSize: {
      delete payload_.max_step_size_;
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Packet::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Packet)
  if (has_header()) {
    if (header_ != NULL) header_->::robotics::gazebotransport::PacketHeader::Clear();
  }
  clear_payload();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Packet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Packet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.PacketHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .robotics.gazebotransport.Packet.CoSimError status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::robotics::gazebotransport::Packet_CoSimError_IsValid(value)) {
            set_status(static_cast< ::robotics::gazebotransport::Packet_CoSimError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_step_simulation;
        break;
      }

      // optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
      case 3: {
        if (tag == 26) {
         parse_step_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_step_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_reset_simulation;
        break;
      }

      // optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
      case 4: {
        if (tag == 34) {
         parse_reset_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reset_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_image;
        break;
      }

      // optional .robotics.gazebotransport.Image image = 5;
      case 5: {
        if (tag == 42) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_request_image;
        break;
      }

      // optional .robotics.gazebotransport.RequestImage request_image = 6;
      case 6: {
        if (tag == 50) {
         parse_request_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_request_cosim;
        break;
      }

      // optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
      case 7: {
        if (tag == 58) {
         parse_request_cosim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_cosim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_stop_cosim;
        break;
      }

      // optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
      case 8: {
        if (tag == 66) {
         parse_stop_cosim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_cosim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_get_ground_truth_world_pose;
        break;
      }

      // optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
      case 9: {
        if (tag == 74) {
         parse_get_ground_truth_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_ground_truth_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_pose;
        break;
      }

      // optional .robotics.gazebotransport.Pose pose = 10;
      case 10: {
        if (tag == 82) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_stop_simulation;
        break;
      }

      // optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
      case 11: {
        if (tag == 90) {
         parse_stop_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_laser_data;
        break;
      }

      // optional .robotics.gazebotransport.LaserData laser_data = 12;
      case 12: {
        if (tag == 98) {
         parse_laser_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_laser_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_request_laser;
        break;
      }

      // optional .robotics.gazebotransport.RequestLaser request_laser = 13;
      case 13: {
        if (tag == 106) {
         parse_request_laser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_laser()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_imu_data;
        break;
      }

      // optional .robotics.gazebotransport.ImuData imu_data = 14;
      case 14: {
        if (tag == 114) {
         parse_imu_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imu_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_request_imu;
        break;
      }

      // optional .robotics.gazebotransport.RequestImu request_imu = 15;
      case 15: {
        if (tag == 122) {
         parse_request_imu:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_imu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_subscribe_image;
        break;
      }

      // optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
      case 16: {
        if (tag == 130) {
         parse_subscribe_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_subscribe_laser;
        break;
      }

      // optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
      case 17: {
        if (tag == 138) {
         parse_subscribe_laser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_laser()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_subscribe_imu;
        break;
      }

      // optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
      case 18: {
        if (tag == 146) {
         parse_subscribe_imu:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_imu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_apply_joint_torque;
        break;
      }

      // optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
      case 19: {
        if (tag == 154) {
         parse_apply_joint_torque:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_apply_joint_torque()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_get_pose;
        break;
      }

      // optional .robotics.gazebotransport.GetPose get_pose = 20;
      case 20: {
        if (tag == 162) {
         parse_get_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_get_topic_list;
        break;
      }

      // optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
      case 21: {
        if (tag == 170) {
         parse_get_topic_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_topic_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_topic_list;
        break;
      }

      // optional .robotics.gazebotransport.TopicList topic_list = 22;
      case 22: {
        if (tag == 178) {
         parse_topic_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_topic_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_get_model_info;
        break;
      }

      // optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
      case 23: {
        if (tag == 186) {
         parse_get_model_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_model_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_model_info;
        break;
      }

      // optional .robotics.gazebotransport.ModelInfo model_info = 24;
      case 24: {
        if (tag == 194) {
         parse_model_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_model_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_apply_link_wrench;
        break;
      }

      // optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
      case 25: {
        if (tag == 202) {
         parse_apply_link_wrench:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_apply_link_wrench()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(210)) goto parse_max_step_size;
        break;
      }

      // optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
      case 26: {
        if (tag == 210) {
         parse_max_step_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_step_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Packet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Packet)
  return false;
#undef DO_
}

void Packet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Packet)
  // required .robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .robotics.gazebotransport.Packet.CoSimError status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
  if (has_step_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *payload_.step_simulation_, output);
  }

  // optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  if (has_reset_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *payload_.reset_simulation_, output);
  }

  // optional .robotics.gazebotransport.Image image = 5;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *payload_.image_, output);
  }

  // optional .robotics.gazebotransport.RequestImage request_image = 6;
  if (has_request_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *payload_.request_image_, output);
  }

  // optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
  if (has_request_cosim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *payload_.request_cosim_, output);
  }

  // optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
  if (has_stop_cosim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *payload_.stop_cosim_, output);
  }

  // optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  if (has_get_ground_truth_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *payload_.get_ground_truth_world_pose_, output);
  }

  // optional .robotics.gazebotransport.Pose pose = 10;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *payload_.pose_, output);
  }

  // optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
  if (has_stop_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *payload_.stop_simulation_, output);
  }

  // optional .robotics.gazebotransport.LaserData laser_data = 12;
  if (has_laser_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *payload_.laser_data_, output);
  }

  // optional .robotics.gazebotransport.RequestLaser request_laser = 13;
  if (has_request_laser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *payload_.request_laser_, output);
  }

  // optional .robotics.gazebotransport.ImuData imu_data = 14;
  if (has_imu_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *payload_.imu_data_, output);
  }

  // optional .robotics.gazebotransport.RequestImu request_imu = 15;
  if (has_request_imu()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *payload_.request_imu_, output);
  }

  // optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  if (has_subscribe_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *payload_.subscribe_image_, output);
  }

  // optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  if (has_subscribe_laser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *payload_.subscribe_laser_, output);
  }

  // optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  if (has_subscribe_imu()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *payload_.subscribe_imu_, output);
  }

  // optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  if (has_apply_joint_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *payload_.apply_joint_torque_, output);
  }

  // optional .robotics.gazebotransport.GetPose get_pose = 20;
  if (has_get_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *payload_.get_pose_, output);
  }

  // optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
  if (has_get_topic_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *payload_.get_topic_list_, output);
  }

  // optional .robotics.gazebotransport.TopicList topic_list = 22;
  if (has_topic_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, *payload_.topic_list_, output);
  }

  // optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
  if (has_get_model_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, *payload_.get_model_info_, output);
  }

  // optional .robotics.gazebotransport.ModelInfo model_info = 24;
  if (has_model_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, *payload_.model_info_, output);
  }

  // optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  if (has_apply_link_wrench()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, *payload_.apply_link_wrench_, output);
  }

  // optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
  if (has_max_step_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, *payload_.max_step_size_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Packet)
}

::google::protobuf::uint8* Packet::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Packet)
  // required .robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // optional .robotics.gazebotransport.Packet.CoSimError status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
  if (has_step_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *payload_.step_simulation_, false, target);
  }

  // optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  if (has_reset_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *payload_.reset_simulation_, false, target);
  }

  // optional .robotics.gazebotransport.Image image = 5;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *payload_.image_, false, target);
  }

  // optional .robotics.gazebotransport.RequestImage request_image = 6;
  if (has_request_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *payload_.request_image_, false, target);
  }

  // optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
  if (has_request_cosim()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *payload_.request_cosim_, false, target);
  }

  // optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
  if (has_stop_cosim()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *payload_.stop_cosim_, false, target);
  }

  // optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  if (has_get_ground_truth_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *payload_.get_ground_truth_world_pose_, false, target);
  }

  // optional .robotics.gazebotransport.Pose pose = 10;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *payload_.pose_, false, target);
  }

  // optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
  if (has_stop_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *payload_.stop_simulation_, false, target);
  }

  // optional .robotics.gazebotransport.LaserData laser_data = 12;
  if (has_laser_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *payload_.laser_data_, false, target);
  }

  // optional .robotics.gazebotransport.RequestLaser request_laser = 13;
  if (has_request_laser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *payload_.request_laser_, false, target);
  }

  // optional .robotics.gazebotransport.ImuData imu_data = 14;
  if (has_imu_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *payload_.imu_data_, false, target);
  }

  // optional .robotics.gazebotransport.RequestImu request_imu = 15;
  if (has_request_imu()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        15, *payload_.request_imu_, false, target);
  }

  // optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  if (has_subscribe_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        16, *payload_.subscribe_image_, false, target);
  }

  // optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  if (has_subscribe_laser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        17, *payload_.subscribe_laser_, false, target);
  }

  // optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  if (has_subscribe_imu()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        18, *payload_.subscribe_imu_, false, target);
  }

  // optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  if (has_apply_joint_torque()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        19, *payload_.apply_joint_torque_, false, target);
  }

  // optional .robotics.gazebotransport.GetPose get_pose = 20;
  if (has_get_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        20, *payload_.get_pose_, false, target);
  }

  // optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
  if (has_get_topic_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        21, *payload_.get_topic_list_, false, target);
  }

  // optional .robotics.gazebotransport.TopicList topic_list = 22;
  if (has_topic_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        22, *payload_.topic_list_, false, target);
  }

  // optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
  if (has_get_model_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        23, *payload_.get_model_info_, false, target);
  }

  // optional .robotics.gazebotransport.ModelInfo model_info = 24;
  if (has_model_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        24, *payload_.model_info_, false, target);
  }

  // optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  if (has_apply_link_wrench()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        25, *payload_.apply_link_wrench_, false, target);
  }

  // optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
  if (has_max_step_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        26, *payload_.max_step_size_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Packet)
  return target;
}

int Packet::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Packet)
  int total_size = 0;

  // required .robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }
  switch (payload_case()) {
    // optional .robotics.gazebotransport.Packet.CoSimError status = 2;
    case kStatus: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
      break;
    }
    // optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
    case kStepSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.step_simulation_);
      break;
    }
    // optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
    case kResetSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.reset_simulation_);
      break;
    }
    // optional .robotics.gazebotransport.Image image = 5;
    case kImage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.image_);
      break;
    }
    // optional .robotics.gazebotransport.RequestImage request_image = 6;
    case kRequestImage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_image_);
      break;
    }
    // optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
    case kRequestCosim: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_cosim_);
      break;
    }
    // optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
    case kStopCosim: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.stop_cosim_);
      break;
    }
    // optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
    case kGetGroundTruthWorldPose: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_ground_truth_world_pose_);
      break;
    }
    // optional .robotics.gazebotransport.Pose pose = 10;
    case kPose: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.pose_);
      break;
    }
    // optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
    case kStopSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.stop_simulation_);
      break;
    }
    // optional .robotics.gazebotransport.LaserData laser_data = 12;
    case kLaserData: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.laser_data_);
      break;
    }
    // optional .robotics.gazebotransport.RequestLaser request_laser = 13;
    case kRequestLaser: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_laser_);
      break;
    }
    // optional .robotics.gazebotransport.ImuData imu_data = 14;
    case kImuData: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.imu_data_);
      break;
    }
    // optional .robotics.gazebotransport.RequestImu request_imu = 15;
    case kRequestImu: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_imu_);
      break;
    }
    // optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
    case kSubscribeImage: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_image_);
      break;
    }
    // optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
    case kSubscribeLaser: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_laser_);
      break;
    }
    // optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
    case kSubscribeImu: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_imu_);
      break;
    }
    // optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
    case kApplyJointTorque: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.apply_joint_torque_);
      break;
    }
    // optional .robotics.gazebotransport.GetPose get_pose = 20;
    case kGetPose: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_pose_);
      break;
    }
    // optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
    case kGetTopicList: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_topic_list_);
      break;
    }
    // optional .robotics.gazebotransport.TopicList topic_list = 22;
    case kTopicList: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.topic_list_);
      break;
    }
    // optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
    case kGetModelInfo: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_model_info_);
      break;
    }
    // optional .robotics.gazebotransport.ModelInfo model_info = 24;
    case kModelInfo: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.model_info_);
      break;
    }
    // optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
    case kApplyLinkWrench: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.apply_link_wrench_);
      break;
    }
    // optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
    case kMaxStepSize: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.max_step_size_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Packet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Packet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Packet* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Packet>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Packet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Packet)
    MergeFrom(*source);
  }
}

void Packet::MergeFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Packet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.payload_case()) {
    case kStatus: {
      set_status(from.status());
      break;
    }
    case kStepSimulation: {
      mutable_step_simulation()->::robotics::gazebotransport::StepSimulation::MergeFrom(from.step_simulation());
      break;
    }
    case kResetSimulation: {
      mutable_reset_simulation()->::robotics::gazebotransport::ResetSimulation::MergeFrom(from.reset_simulation());
      break;
    }
    case kImage: {
      mutable_image()->::robotics::gazebotransport::Image::MergeFrom(from.image());
      break;
    }
    case kRequestImage: {
      mutable_request_image()->::robotics::gazebotransport::RequestImage::MergeFrom(from.request_image());
      break;
    }
    case kRequestCosim: {
      mutable_request_cosim()->::robotics::gazebotransport::RequestCoSim::MergeFrom(from.request_cosim());
      break;
    }
    case kStopCosim: {
      mutable_stop_cosim()->::robotics::gazebotransport::StopCoSim::MergeFrom(from.stop_cosim());
      break;
    }
    case kGetGroundTruthWorldPose: {
      mutable_get_ground_truth_world_pose()->::robotics::gazebotransport::GetGroundTruthWorldPose::MergeFrom(from.get_ground_truth_world_pose());
      break;
    }
    case kPose: {
      mutable_pose()->::robotics::gazebotransport::Pose::MergeFrom(from.pose());
      break;
    }
    case kStopSimulation: {
      mutable_stop_simulation()->::robotics::gazebotransport::StopSimulation::MergeFrom(from.stop_simulation());
      break;
    }
    case kLaserData: {
      mutable_laser_data()->::robotics::gazebotransport::LaserData::MergeFrom(from.laser_data());
      break;
    }
    case kRequestLaser: {
      mutable_request_laser()->::robotics::gazebotransport::RequestLaser::MergeFrom(from.request_laser());
      break;
    }
    case kImuData: {
      mutable_imu_data()->::robotics::gazebotransport::ImuData::MergeFrom(from.imu_data());
      break;
    }
    case kRequestImu: {
      mutable_request_imu()->::robotics::gazebotransport::RequestImu::MergeFrom(from.request_imu());
      break;
    }
    case kSubscribeImage: {
      mutable_subscribe_image()->::robotics::gazebotransport::SubscribeImage::MergeFrom(from.subscribe_image());
      break;
    }
    case kSubscribeLaser: {
      mutable_subscribe_laser()->::robotics::gazebotransport::SubscribeLaser::MergeFrom(from.subscribe_laser());
      break;
    }
    case kSubscribeImu: {
      mutable_subscribe_imu()->::robotics::gazebotransport::SubscribeImu::MergeFrom(from.subscribe_imu());
      break;
    }
    case kApplyJointTorque: {
      mutable_apply_joint_torque()->::robotics::gazebotransport::ApplyJointTorque::MergeFrom(from.apply_joint_torque());
      break;
    }
    case kGetPose: {
      mutable_get_pose()->::robotics::gazebotransport::GetPose::MergeFrom(from.get_pose());
      break;
    }
    case kGetTopicList: {
      mutable_get_topic_list()->::robotics::gazebotransport::GetTopicList::MergeFrom(from.get_topic_list());
      break;
    }
    case kTopicList: {
      mutable_topic_list()->::robotics::gazebotransport::TopicList::MergeFrom(from.topic_list());
      break;
    }
    case kGetModelInfo: {
      mutable_get_model_info()->::robotics::gazebotransport::GetModelInfo::MergeFrom(from.get_model_info());
      break;
    }
    case kModelInfo: {
      mutable_model_info()->::robotics::gazebotransport::ModelInfo::MergeFrom(from.model_info());
      break;
    }
    case kApplyLinkWrench: {
      mutable_apply_link_wrench()->::robotics::gazebotransport::ApplyLinkWrench::MergeFrom(from.apply_link_wrench());
      break;
    }
    case kMaxStepSize: {
      mutable_max_step_size()->::robotics::gazebotransport::MaxStepSize::MergeFrom(from.max_step_size());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::robotics::gazebotransport::PacketHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Packet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Packet::CopyFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Packet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  if (has_step_simulation()) {
    if (!this->step_simulation().IsInitialized()) return false;
  }
  if (has_reset_simulation()) {
    if (!this->reset_simulation().IsInitialized()) return false;
  }
  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  if (has_request_image()) {
    if (!this->request_image().IsInitialized()) return false;
  }
  if (has_request_cosim()) {
    if (!this->request_cosim().IsInitialized()) return false;
  }
  if (has_stop_cosim()) {
    if (!this->stop_cosim().IsInitialized()) return false;
  }
  if (has_get_ground_truth_world_pose()) {
    if (!this->get_ground_truth_world_pose().IsInitialized()) return false;
  }
  if (has_pose()) {
    if (!this->pose().IsInitialized()) return false;
  }
  if (has_stop_simulation()) {
    if (!this->stop_simulation().IsInitialized()) return false;
  }
  if (has_laser_data()) {
    if (!this->laser_data().IsInitialized()) return false;
  }
  if (has_request_laser()) {
    if (!this->request_laser().IsInitialized()) return false;
  }
  if (has_imu_data()) {
    if (!this->imu_data().IsInitialized()) return false;
  }
  if (has_request_imu()) {
    if (!this->request_imu().IsInitialized()) return false;
  }
  if (has_subscribe_image()) {
    if (!this->subscribe_image().IsInitialized()) return false;
  }
  if (has_subscribe_laser()) {
    if (!this->subscribe_laser().IsInitialized()) return false;
  }
  if (has_subscribe_imu()) {
    if (!this->subscribe_imu().IsInitialized()) return false;
  }
  if (has_apply_joint_torque()) {
    if (!this->apply_joint_torque().IsInitialized()) return false;
  }
  if (has_get_pose()) {
    if (!this->get_pose().IsInitialized()) return false;
  }
  if (has_get_topic_list()) {
    if (!this->get_topic_list().IsInitialized()) return false;
  }
  if (has_topic_list()) {
    if (!this->topic_list().IsInitialized()) return false;
  }
  if (has_get_model_info()) {
    if (!this->get_model_info().IsInitialized()) return false;
  }
  if (has_model_info()) {
    if (!this->model_info().IsInitialized()) return false;
  }
  if (has_apply_link_wrench()) {
    if (!this->apply_link_wrench().IsInitialized()) return false;
  }
  if (has_max_step_size()) {
    if (!this->max_step_size().IsInitialized()) return false;
  }
  return true;
}

void Packet::Swap(Packet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Packet::InternalSwap(Packet* other) {
  std::swap(header_, other->header_);
  std::swap(payload_, other->payload_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Packet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Packet_descriptor_;
  metadata.reflection = Packet_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Packet

// required .robotics.gazebotransport.PacketHeader header = 1;
bool Packet::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Packet::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void Packet::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void Packet::clear_header() {
  if (header_ != NULL) header_->::robotics::gazebotransport::PacketHeader::Clear();
  clear_has_header();
}
const ::robotics::gazebotransport::PacketHeader& Packet::header() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::robotics::gazebotransport::PacketHeader;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.header)
  return header_;
}
::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.header)
  clear_has_header();
  ::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void Packet::set_allocated_header(::robotics::gazebotransport::PacketHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.header)
}

// optional .robotics.gazebotransport.Packet.CoSimError status = 2;
bool Packet::has_status() const {
  return payload_case() == kStatus;
}
void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
void Packet::clear_status() {
  if (has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
 ::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.status)
  if (has_status()) {
    return static_cast< ::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::robotics::gazebotransport::Packet_CoSimError >(0);
}
 void Packet::set_status(::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Packet.status)
}

// optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
bool Packet::has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
void Packet::clear_step_simulation() {
  if (has_step_simulation()) {
    delete payload_.step_simulation_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.step_simulation)
  return has_step_simulation()
      ? *payload_.step_simulation_
      : ::robotics::gazebotransport::StepSimulation::default_instance();
}
::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  if (!has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = new ::robotics::gazebotransport::StepSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.step_simulation)
  return payload_.step_simulation_;
}
::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.step_simulation)
  if (has_step_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_step_simulation(::robotics::gazebotransport::StepSimulation* step_simulation) {
  clear_payload();
  if (step_simulation) {
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.step_simulation)
}

// optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
bool Packet::has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
void Packet::clear_reset_simulation() {
  if (has_reset_simulation()) {
    delete payload_.reset_simulation_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.reset_simulation)
  return has_reset_simulation()
      ? *payload_.reset_simulation_
      : ::robotics::gazebotransport::ResetSimulation::default_instance();
}
::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  if (!has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = new ::robotics::gazebotransport::ResetSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.reset_simulation)
  return payload_.reset_simulation_;
}
::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.reset_simulation)
  if (has_reset_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_reset_simulation(::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  clear_payload();
  if (reset_simulation) {
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.reset_simulation)
}

// optional .robotics.gazebotransport.Image image = 5;
bool Packet::has_image() const {
  return payload_case() == kImage;
}
void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
void Packet::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.image)
  return has_image()
      ? *payload_.image_
      : ::robotics::gazebotransport::Image::default_instance();
}
::robotics::gazebotransport::Image* Packet::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = new ::robotics::gazebotransport::Image;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.image)
  return payload_.image_;
}
::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.image)
  if (has_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_image(::robotics::gazebotransport::Image* image) {
  clear_payload();
  if (image) {
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.image)
}

// optional .robotics.gazebotransport.RequestImage request_image = 6;
bool Packet::has_request_image() const {
  return payload_case() == kRequestImage;
}
void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
void Packet::clear_request_image() {
  if (has_request_image()) {
    delete payload_.request_image_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_image)
  return has_request_image()
      ? *payload_.request_image_
      : ::robotics::gazebotransport::RequestImage::default_instance();
}
::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  if (!has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = new ::robotics::gazebotransport::RequestImage;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_image)
  return payload_.request_image_;
}
::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_image)
  if (has_request_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_image(::robotics::gazebotransport::RequestImage* request_image) {
  clear_payload();
  if (request_image) {
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_image)
}

// optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
bool Packet::has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
void Packet::clear_request_cosim() {
  if (has_request_cosim()) {
    delete payload_.request_cosim_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_cosim)
  return has_request_cosim()
      ? *payload_.request_cosim_
      : ::robotics::gazebotransport::RequestCoSim::default_instance();
}
::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  if (!has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = new ::robotics::gazebotransport::RequestCoSim;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_cosim)
  return payload_.request_cosim_;
}
::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_cosim)
  if (has_request_cosim()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_cosim(::robotics::gazebotransport::RequestCoSim* request_cosim) {
  clear_payload();
  if (request_cosim) {
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_cosim)
}

// optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
bool Packet::has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
void Packet::clear_stop_cosim() {
  if (has_stop_cosim()) {
    delete payload_.stop_cosim_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.stop_cosim)
  return has_stop_cosim()
      ? *payload_.stop_cosim_
      : ::robotics::gazebotransport::StopCoSim::default_instance();
}
::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  if (!has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = new ::robotics::gazebotransport::StopCoSim;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.stop_cosim)
  return payload_.stop_cosim_;
}
::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.stop_cosim)
  if (has_stop_cosim()) {
    clear_has_payload();
    ::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_stop_cosim(::robotics::gazebotransport::StopCoSim* stop_cosim) {
  clear_payload();
  if (stop_cosim) {
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.stop_cosim)
}

// optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
bool Packet::has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
void Packet::clear_get_ground_truth_world_pose() {
  if (has_get_ground_truth_world_pose()) {
    delete payload_.get_ground_truth_world_pose_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : ::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance();
}
::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  if (!has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = new ::robotics::gazebotransport::GetGroundTruthWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return payload_.get_ground_truth_world_pose_;
}
::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (has_get_ground_truth_world_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_ground_truth_world_pose(::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  clear_payload();
  if (get_ground_truth_world_pose) {
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}

// optional .robotics.gazebotransport.Pose pose = 10;
bool Packet::has_pose() const {
  return payload_case() == kPose;
}
void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
void Packet::clear_pose() {
  if (has_pose()) {
    delete payload_.pose_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.pose)
  return has_pose()
      ? *payload_.pose_
      : ::robotics::gazebotransport::Pose::default_instance();
}
::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  if (!has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = new ::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.pose)
  return payload_.pose_;
}
::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.pose)
  if (has_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_pose(::robotics::gazebotransport::Pose* pose) {
  clear_payload();
  if (pose) {
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.pose)
}

// optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
bool Packet::has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
void Packet::clear_stop_simulation() {
  if (has_stop_simulation()) {
    delete payload_.stop_simulation_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.stop_simulation)
  return has_stop_simulation()
      ? *payload_.stop_simulation_
      : ::robotics::gazebotransport::StopSimulation::default_instance();
}
::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  if (!has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = new ::robotics::gazebotransport::StopSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.stop_simulation)
  return payload_.stop_simulation_;
}
::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.stop_simulation)
  if (has_stop_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_stop_simulation(::robotics::gazebotransport::StopSimulation* stop_simulation) {
  clear_payload();
  if (stop_simulation) {
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.stop_simulation)
}

// optional .robotics.gazebotransport.LaserData laser_data = 12;
bool Packet::has_laser_data() const {
  return payload_case() == kLaserData;
}
void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
void Packet::clear_laser_data() {
  if (has_laser_data()) {
    delete payload_.laser_data_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.laser_data)
  return has_laser_data()
      ? *payload_.laser_data_
      : ::robotics::gazebotransport::LaserData::default_instance();
}
::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  if (!has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = new ::robotics::gazebotransport::LaserData;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.laser_data)
  return payload_.laser_data_;
}
::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.laser_data)
  if (has_laser_data()) {
    clear_has_payload();
    ::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_laser_data(::robotics::gazebotransport::LaserData* laser_data) {
  clear_payload();
  if (laser_data) {
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.laser_data)
}

// optional .robotics.gazebotransport.RequestLaser request_laser = 13;
bool Packet::has_request_laser() const {
  return payload_case() == kRequestLaser;
}
void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
void Packet::clear_request_laser() {
  if (has_request_laser()) {
    delete payload_.request_laser_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_laser)
  return has_request_laser()
      ? *payload_.request_laser_
      : ::robotics::gazebotransport::RequestLaser::default_instance();
}
::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  if (!has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = new ::robotics::gazebotransport::RequestLaser;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_laser)
  return payload_.request_laser_;
}
::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_laser)
  if (has_request_laser()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_laser(::robotics::gazebotransport::RequestLaser* request_laser) {
  clear_payload();
  if (request_laser) {
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_laser)
}

// optional .robotics.gazebotransport.ImuData imu_data = 14;
bool Packet::has_imu_data() const {
  return payload_case() == kImuData;
}
void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
void Packet::clear_imu_data() {
  if (has_imu_data()) {
    delete payload_.imu_data_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.imu_data)
  return has_imu_data()
      ? *payload_.imu_data_
      : ::robotics::gazebotransport::ImuData::default_instance();
}
::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = new ::robotics::gazebotransport::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.imu_data)
  return payload_.imu_data_;
}
::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.imu_data)
  if (has_imu_data()) {
    clear_has_payload();
    ::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_imu_data(::robotics::gazebotransport::ImuData* imu_data) {
  clear_payload();
  if (imu_data) {
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.imu_data)
}

// optional .robotics.gazebotransport.RequestImu request_imu = 15;
bool Packet::has_request_imu() const {
  return payload_case() == kRequestImu;
}
void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
void Packet::clear_request_imu() {
  if (has_request_imu()) {
    delete payload_.request_imu_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_imu)
  return has_request_imu()
      ? *payload_.request_imu_
      : ::robotics::gazebotransport::RequestImu::default_instance();
}
::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  if (!has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = new ::robotics::gazebotransport::RequestImu;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_imu)
  return payload_.request_imu_;
}
::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_imu)
  if (has_request_imu()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_imu(::robotics::gazebotransport::RequestImu* request_imu) {
  clear_payload();
  if (request_imu) {
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_imu)
}

// optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
bool Packet::has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
void Packet::clear_subscribe_image() {
  if (has_subscribe_image()) {
    delete payload_.subscribe_image_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_image)
  return has_subscribe_image()
      ? *payload_.subscribe_image_
      : ::robotics::gazebotransport::SubscribeImage::default_instance();
}
::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  if (!has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = new ::robotics::gazebotransport::SubscribeImage;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_image)
  return payload_.subscribe_image_;
}
::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_image)
  if (has_subscribe_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_image(::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  clear_payload();
  if (subscribe_image) {
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_image)
}

// optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
bool Packet::has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
void Packet::clear_subscribe_laser() {
  if (has_subscribe_laser()) {
    delete payload_.subscribe_laser_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_laser)
  return has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : ::robotics::gazebotransport::SubscribeLaser::default_instance();
}
::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  if (!has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = new ::robotics::gazebotransport::SubscribeLaser;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_laser)
  return payload_.subscribe_laser_;
}
::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_laser)
  if (has_subscribe_laser()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_laser(::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  clear_payload();
  if (subscribe_laser) {
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_laser)
}

// optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
bool Packet::has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
void Packet::clear_subscribe_imu() {
  if (has_subscribe_imu()) {
    delete payload_.subscribe_imu_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_imu)
  return has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : ::robotics::gazebotransport::SubscribeImu::default_instance();
}
::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  if (!has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = new ::robotics::gazebotransport::SubscribeImu;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_imu)
  return payload_.subscribe_imu_;
}
::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_imu)
  if (has_subscribe_imu()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_imu(::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  clear_payload();
  if (subscribe_imu) {
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_imu)
}

// optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
bool Packet::has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
void Packet::clear_apply_joint_torque() {
  if (has_apply_joint_torque()) {
    delete payload_.apply_joint_torque_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.apply_joint_torque)
  return has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : ::robotics::gazebotransport::ApplyJointTorque::default_instance();
}
::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  if (!has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = new ::robotics::gazebotransport::ApplyJointTorque;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.apply_joint_torque)
  return payload_.apply_joint_torque_;
}
::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.apply_joint_torque)
  if (has_apply_joint_torque()) {
    clear_has_payload();
    ::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_apply_joint_torque(::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  clear_payload();
  if (apply_joint_torque) {
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.apply_joint_torque)
}

// optional .robotics.gazebotransport.GetPose get_pose = 20;
bool Packet::has_get_pose() const {
  return payload_case() == kGetPose;
}
void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
void Packet::clear_get_pose() {
  if (has_get_pose()) {
    delete payload_.get_pose_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_pose)
  return has_get_pose()
      ? *payload_.get_pose_
      : ::robotics::gazebotransport::GetPose::default_instance();
}
::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  if (!has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = new ::robotics::gazebotransport::GetPose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_pose)
  return payload_.get_pose_;
}
::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_pose)
  if (has_get_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_pose(::robotics::gazebotransport::GetPose* get_pose) {
  clear_payload();
  if (get_pose) {
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_pose)
}

// optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
bool Packet::has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
void Packet::clear_get_topic_list() {
  if (has_get_topic_list()) {
    delete payload_.get_topic_list_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_topic_list)
  return has_get_topic_list()
      ? *payload_.get_topic_list_
      : ::robotics::gazebotransport::GetTopicList::default_instance();
}
::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  if (!has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = new ::robotics::gazebotransport::GetTopicList;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_topic_list)
  return payload_.get_topic_list_;
}
::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_topic_list)
  if (has_get_topic_list()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_topic_list(::robotics::gazebotransport::GetTopicList* get_topic_list) {
  clear_payload();
  if (get_topic_list) {
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_topic_list)
}

// optional .robotics.gazebotransport.TopicList topic_list = 22;
bool Packet::has_topic_list() const {
  return payload_case() == kTopicList;
}
void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
void Packet::clear_topic_list() {
  if (has_topic_list()) {
    delete payload_.topic_list_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.topic_list)
  return has_topic_list()
      ? *payload_.topic_list_
      : ::robotics::gazebotransport::TopicList::default_instance();
}
::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  if (!has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = new ::robotics::gazebotransport::TopicList;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.topic_list)
  return payload_.topic_list_;
}
::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.topic_list)
  if (has_topic_list()) {
    clear_has_payload();
    ::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_topic_list(::robotics::gazebotransport::TopicList* topic_list) {
  clear_payload();
  if (topic_list) {
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.topic_list)
}

// optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
bool Packet::has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
void Packet::clear_get_model_info() {
  if (has_get_model_info()) {
    delete payload_.get_model_info_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_model_info)
  return has_get_model_info()
      ? *payload_.get_model_info_
      : ::robotics::gazebotransport::GetModelInfo::default_instance();
}
::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  if (!has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = new ::robotics::gazebotransport::GetModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_model_info)
  return payload_.get_model_info_;
}
::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_model_info)
  if (has_get_model_info()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_model_info(::robotics::gazebotransport::GetModelInfo* get_model_info) {
  clear_payload();
  if (get_model_info) {
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_model_info)
}

// optional .robotics.gazebotransport.ModelInfo model_info = 24;
bool Packet::has_model_info() const {
  return payload_case() == kModelInfo;
}
void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
void Packet::clear_model_info() {
  if (has_model_info()) {
    delete payload_.model_info_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.model_info)
  return has_model_info()
      ? *payload_.model_info_
      : ::robotics::gazebotransport::ModelInfo::default_instance();
}
::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  if (!has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = new ::robotics::gazebotransport::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.model_info)
  return payload_.model_info_;
}
::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.model_info)
  if (has_model_info()) {
    clear_has_payload();
    ::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_model_info(::robotics::gazebotransport::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.model_info)
}

// optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
bool Packet::has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
void Packet::clear_apply_link_wrench() {
  if (has_apply_link_wrench()) {
    delete payload_.apply_link_wrench_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.apply_link_wrench)
  return has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : ::robotics::gazebotransport::ApplyLinkWrench::default_instance();
}
::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  if (!has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = new ::robotics::gazebotransport::ApplyLinkWrench;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.apply_link_wrench)
  return payload_.apply_link_wrench_;
}
::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.apply_link_wrench)
  if (has_apply_link_wrench()) {
    clear_has_payload();
    ::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_apply_link_wrench(::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  clear_payload();
  if (apply_link_wrench) {
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.apply_link_wrench)
}

// optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
bool Packet::has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
void Packet::clear_max_step_size() {
  if (has_max_step_size()) {
    delete payload_.max_step_size_;
    clear_has_payload();
  }
}
 const ::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.max_step_size)
  return has_max_step_size()
      ? *payload_.max_step_size_
      : ::robotics::gazebotransport::MaxStepSize::default_instance();
}
::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  if (!has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = new ::robotics::gazebotransport::MaxStepSize;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.max_step_size)
  return payload_.max_step_size_;
}
::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.max_step_size)
  if (has_max_step_size()) {
    clear_has_payload();
    ::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_max_step_size(::robotics::gazebotransport::MaxStepSize* max_step_size) {
  clear_payload();
  if (max_step_size) {
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.max_step_size)
}

bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StepSimulation::kNumStepsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StepSimulation::StepSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.StepSimulation)
}

void StepSimulation::InitAsDefaultInstance() {
}

StepSimulation::StepSimulation(const StepSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.StepSimulation)
}

void StepSimulation::SharedCtor() {
  _cached_size_ = 0;
  num_steps_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StepSimulation::~StepSimulation() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.StepSimulation)
  SharedDtor();
}

void StepSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StepSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StepSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StepSimulation_descriptor_;
}

const StepSimulation& StepSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StepSimulation* StepSimulation::default_instance_ = NULL;

StepSimulation* StepSimulation::New(::google::protobuf::Arena* arena) const {
  StepSimulation* n = new StepSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StepSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.StepSimulation)
  num_steps_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StepSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.StepSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 num_steps = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_steps_)));
          set_has_num_steps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.StepSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.StepSimulation)
  return false;
#undef DO_
}

void StepSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.StepSimulation)
  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num_steps(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.StepSimulation)
}

::google::protobuf::uint8* StepSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.StepSimulation)
  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->num_steps(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.StepSimulation)
  return target;
}

int StepSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.StepSimulation)
  int total_size = 0;

  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->num_steps());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StepSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.StepSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StepSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StepSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.StepSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.StepSimulation)
    MergeFrom(*source);
  }
}

void StepSimulation::MergeFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.StepSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_steps()) {
      set_num_steps(from.num_steps());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StepSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StepSimulation::CopyFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StepSimulation::Swap(StepSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StepSimulation::InternalSwap(StepSimulation* other) {
  std::swap(num_steps_, other->num_steps_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StepSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StepSimulation_descriptor_;
  metadata.reflection = StepSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StepSimulation

// required uint32 num_steps = 1;
bool StepSimulation::has_num_steps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StepSimulation::set_has_num_steps() {
  _has_bits_[0] |= 0x00000001u;
}
void StepSimulation::clear_has_num_steps() {
  _has_bits_[0] &= ~0x00000001u;
}
void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  clear_has_num_steps();
}
 ::google::protobuf::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StepSimulation.num_steps)
  return num_steps_;
}
 void StepSimulation::set_num_steps(::google::protobuf::uint32 value) {
  set_has_num_steps();
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StepSimulation.num_steps)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetSimulation_ResetBehavior_descriptor_;
}
bool ResetSimulation_ResetBehavior_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME;
const ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME_AND_SCENE;
const ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MIN;
const ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MAX;
const int ResetSimulation::ResetBehavior_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResetSimulation::kBehaviorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResetSimulation::ResetSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ResetSimulation)
}

void ResetSimulation::InitAsDefaultInstance() {
}

ResetSimulation::ResetSimulation(const ResetSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ResetSimulation)
}

void ResetSimulation::SharedCtor() {
  _cached_size_ = 0;
  behavior_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetSimulation::~ResetSimulation() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ResetSimulation)
  SharedDtor();
}

void ResetSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResetSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetSimulation_descriptor_;
}

const ResetSimulation& ResetSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ResetSimulation* ResetSimulation::default_instance_ = NULL;

ResetSimulation* ResetSimulation::New(::google::protobuf::Arena* arena) const {
  ResetSimulation* n = new ResetSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResetSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ResetSimulation)
  behavior_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResetSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ResetSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value)) {
            set_behavior(static_cast< ::robotics::gazebotransport::ResetSimulation_ResetBehavior >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ResetSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ResetSimulation)
  return false;
#undef DO_
}

void ResetSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ResetSimulation)
  // required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->behavior(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ResetSimulation)
}

::google::protobuf::uint8* ResetSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ResetSimulation)
  // required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->behavior(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ResetSimulation)
  return target;
}

int ResetSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ResetSimulation)
  int total_size = 0;

  // required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->behavior());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ResetSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResetSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResetSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ResetSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ResetSimulation)
    MergeFrom(*source);
  }
}

void ResetSimulation::MergeFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ResetSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_behavior()) {
      set_behavior(from.behavior());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResetSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetSimulation::CopyFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ResetSimulation::Swap(ResetSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResetSimulation::InternalSwap(ResetSimulation* other) {
  std::swap(behavior_, other->behavior_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResetSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetSimulation_descriptor_;
  metadata.reflection = ResetSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResetSimulation

// required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
bool ResetSimulation::has_behavior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResetSimulation::set_has_behavior() {
  _has_bits_[0] |= 0x00000001u;
}
void ResetSimulation::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  clear_has_behavior();
}
 ::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ResetSimulation.behavior)
  return static_cast< ::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
 void ResetSimulation::set_behavior(::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  set_has_behavior();
  behavior_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ResetSimulation.behavior)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kDataFieldNumber;
const int Image::kDataTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Image)
}

void Image::InitAsDefaultInstance() {
}

Image::Image(const Image& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Image)
}

void Image::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  width_ = 0u;
  height_ = 0u;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Image)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Image, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Image*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(width_, height_);
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_data_type()) {
      data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 width = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // required uint32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data_type;
        break;
      }

      // required string data_type = 4;
      case 4: {
        if (tag == 34) {
         parse_data_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->data_type().data(), this->data_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.Image.data_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Image)
  // required uint32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->width(), output);
  }

  // required uint32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->height(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // required string data_type = 4;
  if (has_data_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data_type().data(), this->data_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.Image.data_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->data_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Image)
}

::google::protobuf::uint8* Image::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Image)
  // required uint32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->width(), target);
  }

  // required uint32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->height(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // required string data_type = 4;
  if (has_data_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data_type().data(), this->data_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.Image.data_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->data_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Image)
  return target;
}

int Image::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.Image)
  int total_size = 0;

  if (has_width()) {
    // required uint32 width = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());
  }

  if (has_height()) {
    // required uint32 height = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());
  }

  if (has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  if (has_data_type()) {
    // required string data_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data_type());
  }

  return total_size;
}
int Image::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Image)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 width = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());

    // required uint32 height = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());

    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());

    // required string data_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Image* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Image>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Image)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_data_type()) {
      set_has_data_type();
      data_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  data_.Swap(&other->data_);
  data_type_.Swap(&other->data_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// required uint32 width = 1;
bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Image::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
 ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.width)
  return width_;
}
 void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.width)
}

// required uint32 height = 2;
bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Image::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
 ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.height)
  return height_;
}
 void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.height)
}

// required bytes data = 3;
bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Image::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.data)
}
 void Image::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.Image.data)
}
 void Image::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.Image.data)
}
 ::std::string* Image::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Image.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Image.data)
}

// required string data_type = 4;
bool Image::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Image::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
void Image::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void Image::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
 const ::std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.data_type)
  return data_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.data_type)
}
 void Image::set_data_type(const char* value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.Image.data_type)
}
 void Image::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.Image.data_type)
}
 ::std::string* Image::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Image.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Image.data_type)
  clear_has_data_type();
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Image.data_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestImage::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestImage::RequestImage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.RequestImage)
}

void RequestImage::InitAsDefaultInstance() {
}

RequestImage::RequestImage(const RequestImage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.RequestImage)
}

void RequestImage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestImage::~RequestImage() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.RequestImage)
  SharedDtor();
}

void RequestImage::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestImage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestImage_descriptor_;
}

const RequestImage& RequestImage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestImage* RequestImage::default_instance_ = NULL;

RequestImage* RequestImage::New(::google::protobuf::Arena* arena) const {
  RequestImage* n = new RequestImage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestImage::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.RequestImage)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.RequestImage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.RequestImage.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.RequestImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.RequestImage)
  return false;
#undef DO_
}

void RequestImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.RequestImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestImage.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.RequestImage)
}

::google::protobuf::uint8* RequestImage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.RequestImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestImage.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.RequestImage)
  return target;
}

int RequestImage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.RequestImage)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestImage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.RequestImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestImage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestImage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.RequestImage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.RequestImage)
    MergeFrom(*source);
  }
}

void RequestImage::MergeFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.RequestImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestImage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImage::CopyFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestImage::Swap(RequestImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestImage::InternalSwap(RequestImage* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestImage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestImage_descriptor_;
  metadata.reflection = RequestImage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestImage

// required string topic_name = 1;
bool RequestImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestImage.topic_name)
}
 void RequestImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestImage.topic_name)
}
 void RequestImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestImage.topic_name)
}
 ::std::string* RequestImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestImage.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestCoSim::kClientIdFieldNumber;
const int RequestCoSim::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestCoSim::RequestCoSim()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.RequestCoSim)
}

void RequestCoSim::InitAsDefaultInstance() {
}

RequestCoSim::RequestCoSim(const RequestCoSim& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.RequestCoSim)
}

void RequestCoSim::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  duration_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCoSim::~RequestCoSim() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.RequestCoSim)
  SharedDtor();
}

void RequestCoSim::SharedDtor() {
  client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestCoSim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestCoSim::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestCoSim_descriptor_;
}

const RequestCoSim& RequestCoSim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestCoSim* RequestCoSim::default_instance_ = NULL;

RequestCoSim* RequestCoSim::New(::google::protobuf::Arena* arena) const {
  RequestCoSim* n = new RequestCoSim;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.RequestCoSim)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_client_id()) {
      client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    duration_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestCoSim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.RequestCoSim)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string client_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_id().data(), this->client_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.RequestCoSim.client_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_duration;
        break;
      }

      // required double duration = 2;
      case 2: {
        if (tag == 17) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.RequestCoSim)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.RequestCoSim)
  return false;
#undef DO_
}

void RequestCoSim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.RequestCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestCoSim.client_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_id(), output);
  }

  // required double duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->duration(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.RequestCoSim)
}

::google::protobuf::uint8* RequestCoSim::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.RequestCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestCoSim.client_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->client_id(), target);
  }

  // required double duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->duration(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.RequestCoSim)
  return target;
}

int RequestCoSim::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.RequestCoSim)
  int total_size = 0;

  if (has_client_id()) {
    // required string client_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());
  }

  if (has_duration()) {
    // required double duration = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int RequestCoSim::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.RequestCoSim)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string client_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());

    // required double duration = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCoSim::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.RequestCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestCoSim* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestCoSim>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.RequestCoSim)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.RequestCoSim)
    MergeFrom(*source);
  }
}

void RequestCoSim::MergeFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.RequestCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_id()) {
      set_has_client_id();
      client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestCoSim::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCoSim::CopyFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCoSim::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestCoSim::Swap(RequestCoSim* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestCoSim::InternalSwap(RequestCoSim* other) {
  client_id_.Swap(&other->client_id_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestCoSim::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestCoSim_descriptor_;
  metadata.reflection = RequestCoSim_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestCoSim

// required string client_id = 1;
bool RequestCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
 const ::std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestCoSim.client_id)
}
 void RequestCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestCoSim.client_id)
}
 void RequestCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestCoSim.client_id)
}
 ::std::string* RequestCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
bool RequestCoSim::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestCoSim::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestCoSim::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestCoSim::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
 double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestCoSim.duration)
  return duration_;
}
 void RequestCoSim::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestCoSim.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopCoSim::kClientIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopCoSim::StopCoSim()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.StopCoSim)
}

void StopCoSim::InitAsDefaultInstance() {
}

StopCoSim::StopCoSim(const StopCoSim& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.StopCoSim)
}

void StopCoSim::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopCoSim::~StopCoSim() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.StopCoSim)
  SharedDtor();
}

void StopCoSim::SharedDtor() {
  client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void StopCoSim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopCoSim::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StopCoSim_descriptor_;
}

const StopCoSim& StopCoSim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StopCoSim* StopCoSim::default_instance_ = NULL;

StopCoSim* StopCoSim::New(::google::protobuf::Arena* arena) const {
  StopCoSim* n = new StopCoSim;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.StopCoSim)
  if (has_client_id()) {
    client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StopCoSim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.StopCoSim)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string client_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_id().data(), this->client_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.StopCoSim.client_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.StopCoSim)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.StopCoSim)
  return false;
#undef DO_
}

void StopCoSim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.StopCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.StopCoSim.client_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.StopCoSim)
}

::google::protobuf::uint8* StopCoSim::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.StopCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.StopCoSim.client_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->client_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.StopCoSim)
  return target;
}

int StopCoSim::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.StopCoSim)
  int total_size = 0;

  // required string client_id = 1;
  if (has_client_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopCoSim::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.StopCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StopCoSim* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StopCoSim>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.StopCoSim)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.StopCoSim)
    MergeFrom(*source);
  }
}

void StopCoSim::MergeFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.StopCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_id()) {
      set_has_client_id();
      client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StopCoSim::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopCoSim::CopyFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopCoSim::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StopCoSim::Swap(StopCoSim* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopCoSim::InternalSwap(StopCoSim* other) {
  client_id_.Swap(&other->client_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopCoSim::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StopCoSim_descriptor_;
  metadata.reflection = StopCoSim_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopCoSim

// required string client_id = 1;
bool StopCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
void StopCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
 const ::std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StopCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StopCoSim.client_id)
}
 void StopCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.StopCoSim.client_id)
}
 void StopCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.StopCoSim.client_id)
}
 ::std::string* StopCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.StopCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StopCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.StopCoSim.client_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetGroundTruthWorldPose::kModelNameFieldNumber;
const int GetGroundTruthWorldPose::kLinkNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetGroundTruthWorldPose::GetGroundTruthWorldPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.GetGroundTruthWorldPose)
}

void GetGroundTruthWorldPose::InitAsDefaultInstance() {
}

GetGroundTruthWorldPose::GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.GetGroundTruthWorldPose)
}

void GetGroundTruthWorldPose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGroundTruthWorldPose::~GetGroundTruthWorldPose() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.GetGroundTruthWorldPose)
  SharedDtor();
}

void GetGroundTruthWorldPose::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetGroundTruthWorldPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetGroundTruthWorldPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetGroundTruthWorldPose_descriptor_;
}

const GetGroundTruthWorldPose& GetGroundTruthWorldPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetGroundTruthWorldPose* GetGroundTruthWorldPose::default_instance_ = NULL;

GetGroundTruthWorldPose* GetGroundTruthWorldPose::New(::google::protobuf::Arena* arena) const {
  GetGroundTruthWorldPose* n = new GetGroundTruthWorldPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetGroundTruthWorldPose::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetGroundTruthWorldPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.GetGroundTruthWorldPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.GetGroundTruthWorldPose)
  return false;
#undef DO_
}

void GetGroundTruthWorldPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.GetGroundTruthWorldPose)
}

::google::protobuf::uint8* GetGroundTruthWorldPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.GetGroundTruthWorldPose)
  return target;
}

int GetGroundTruthWorldPose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  return total_size;
}
int GetGroundTruthWorldPose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGroundTruthWorldPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetGroundTruthWorldPose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetGroundTruthWorldPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.GetGroundTruthWorldPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.GetGroundTruthWorldPose)
    MergeFrom(*source);
  }
}

void GetGroundTruthWorldPose::MergeFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetGroundTruthWorldPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGroundTruthWorldPose::CopyFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGroundTruthWorldPose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetGroundTruthWorldPose::Swap(GetGroundTruthWorldPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetGroundTruthWorldPose::InternalSwap(GetGroundTruthWorldPose* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetGroundTruthWorldPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetGroundTruthWorldPose_descriptor_;
  metadata.reflection = GetGroundTruthWorldPose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetGroundTruthWorldPose

// required string model_name = 1;
bool GetGroundTruthWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetGroundTruthWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetGroundTruthWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 void GetGroundTruthWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 void GetGroundTruthWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 ::std::string* GetGroundTruthWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
bool GetGroundTruthWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetGroundTruthWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetGroundTruthWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 void GetGroundTruthWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 void GetGroundTruthWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 ::std::string* GetGroundTruthWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
const int Point::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point::Point()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Point)
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Point)
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Point)
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point_descriptor_;
}

const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New(::google::protobuf::Arena* arena) const {
  Point* n = new Point;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Point)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Point, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Point*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Point)
  return false;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Point)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Point)
}

::google::protobuf::uint8* Point::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Point)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Point)
  return target;
}

int Point::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.Point)
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int Point::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Point)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Point* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Point>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Point)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Point)
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Point::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Point::Swap(Point* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point::InternalSwap(Point* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point_descriptor_;
  metadata.reflection = Point_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Point

// required double x = 1;
bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Point::x() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.x)
  return x_;
}
 void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.x)
}

// required double y = 2;
bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Point::y() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.y)
  return y_;
}
 void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.y)
}

// required double z = 3;
bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Point::z() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.z)
  return z_;
}
 void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kXFieldNumber;
const int Quaternion::kYFieldNumber;
const int Quaternion::kZFieldNumber;
const int Quaternion::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Quaternion)
}

void Quaternion::InitAsDefaultInstance() {
}

Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Quaternion)
}

void Quaternion::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Quaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Quaternion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Quaternion_descriptor_;
}

const Quaternion& Quaternion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Quaternion* Quaternion::default_instance_ = NULL;

Quaternion* Quaternion::New(::google::protobuf::Arena* arena) const {
  Quaternion* n = new Quaternion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Quaternion)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Quaternion, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Quaternion*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Quaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_w;
        break;
      }

      // required double w = 4;
      case 4: {
        if (tag == 33) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Quaternion)
  return false;
#undef DO_
}

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Quaternion)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // required double w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Quaternion)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // required double w = 4;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Quaternion)
  return target;
}

int Quaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.Quaternion)
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
int Quaternion::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Quaternion)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

    // required double w = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Quaternion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Quaternion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Quaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Quaternion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Quaternion_descriptor_;
  metadata.reflection = Quaternion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Quaternion

// required double x = 1;
bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.x)
  return x_;
}
 void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.y)
  return y_;
}
 void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.z)
  return z_;
}
 void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.w)
  return w_;
}
 void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose::kPositionFieldNumber;
const int Pose::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose::Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.Pose)
}

void Pose::InitAsDefaultInstance() {
  position_ = const_cast< ::robotics::gazebotransport::Point*>(&::robotics::gazebotransport::Point::default_instance());
  orientation_ = const_cast< ::robotics::gazebotransport::Quaternion*>(&::robotics::gazebotransport::Quaternion::default_instance());
}

Pose::Pose(const Pose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.Pose)
}

void Pose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.Pose)
  SharedDtor();
}

void Pose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete orientation_;
  }
}

void Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pose_descriptor_;
}

const Pose& Pose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Pose* Pose::default_instance_ = NULL;

Pose* Pose::New(::google::protobuf::Arena* arena) const {
  Pose* n = new Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.Pose)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_position()) {
      if (position_ != NULL) position_->::robotics::gazebotransport::Point::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.Point position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orientation;
        break;
      }

      // required .robotics.gazebotransport.Quaternion orientation = 2;
      case 2: {
        if (tag == 18) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.Pose)
  return false;
#undef DO_
}

void Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.Pose)
  // required .robotics.gazebotransport.Point position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // required .robotics.gazebotransport.Quaternion orientation = 2;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orientation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.Pose)
}

::google::protobuf::uint8* Pose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.Pose)
  // required .robotics.gazebotransport.Point position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->position_, false, target);
  }

  // required .robotics.gazebotransport.Quaternion orientation = 2;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->orientation_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.Pose)
  return target;
}

int Pose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.Pose)
  int total_size = 0;

  if (has_position()) {
    // required .robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  if (has_orientation()) {
    // required .robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);
  }

  return total_size;
}
int Pose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.Pose)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

    // required .robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Pose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.Pose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.Pose)
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::robotics::gazebotransport::Point::MergeFrom(from.position());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::robotics::gazebotransport::Quaternion::MergeFrom(from.orientation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Pose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_orientation()) {
    if (!this->orientation_->IsInitialized()) return false;
  }
  return true;
}

void Pose::Swap(Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose::InternalSwap(Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orientation_, other->orientation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pose_descriptor_;
  metadata.reflection = Pose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose

// required .robotics.gazebotransport.Point position = 1;
bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void Pose::clear_position() {
  if (position_ != NULL) position_->::robotics::gazebotransport::Point::Clear();
  clear_has_position();
}
const ::robotics::gazebotransport::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::robotics::gazebotransport::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Pose.position)
  return position_;
}
::robotics::gazebotransport::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Pose.position)
  clear_has_position();
  ::robotics::gazebotransport::Point* temp = position_;
  position_ = NULL;
  return temp;
}
void Pose::set_allocated_position(::robotics::gazebotransport::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Pose.position)
}

// required .robotics.gazebotransport.Quaternion orientation = 2;
bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
const ::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Pose.orientation)
  return orientation_;
}
::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Pose.orientation)
  clear_has_orientation();
  ::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void Pose::set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Pose.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopSimulation::kStopSceneFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopSimulation::StopSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.StopSimulation)
}

void StopSimulation::InitAsDefaultInstance() {
}

StopSimulation::StopSimulation(const StopSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.StopSimulation)
}

void StopSimulation::SharedCtor() {
  _cached_size_ = 0;
  stop_scene_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopSimulation::~StopSimulation() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.StopSimulation)
  SharedDtor();
}

void StopSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StopSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StopSimulation_descriptor_;
}

const StopSimulation& StopSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StopSimulation* StopSimulation::default_instance_ = NULL;

StopSimulation* StopSimulation::New(::google::protobuf::Arena* arena) const {
  StopSimulation* n = new StopSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.StopSimulation)
  stop_scene_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StopSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.StopSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool stop_scene = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stop_scene_)));
          set_has_stop_scene();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.StopSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.StopSimulation)
  return false;
#undef DO_
}

void StopSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.StopSimulation)
  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->stop_scene(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.StopSimulation)
}

::google::protobuf::uint8* StopSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.StopSimulation)
  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->stop_scene(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.StopSimulation)
  return target;
}

int StopSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.StopSimulation)
  int total_size = 0;

  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    total_size += 1 + 1;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.StopSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StopSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StopSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.StopSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.StopSimulation)
    MergeFrom(*source);
  }
}

void StopSimulation::MergeFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.StopSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stop_scene()) {
      set_stop_scene(from.stop_scene());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StopSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopSimulation::CopyFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StopSimulation::Swap(StopSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopSimulation::InternalSwap(StopSimulation* other) {
  std::swap(stop_scene_, other->stop_scene_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StopSimulation_descriptor_;
  metadata.reflection = StopSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopSimulation

// required bool stop_scene = 1;
bool StopSimulation::has_stop_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopSimulation::set_has_stop_scene() {
  _has_bits_[0] |= 0x00000001u;
}
void StopSimulation::clear_has_stop_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  clear_has_stop_scene();
}
 bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StopSimulation.stop_scene)
  return stop_scene_;
}
 void StopSimulation::set_stop_scene(bool value) {
  set_has_stop_scene();
  stop_scene_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StopSimulation.stop_scene)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserData::kAngleMinFieldNumber;
const int LaserData::kAngleMaxFieldNumber;
const int LaserData::kAngleStepFieldNumber;
const int LaserData::kRangeMinFieldNumber;
const int LaserData::kRangeMaxFieldNumber;
const int LaserData::kCountFieldNumber;
const int LaserData::kVerticalAngleMinFieldNumber;
const int LaserData::kVerticalAngleMaxFieldNumber;
const int LaserData::kVerticalAngleStepFieldNumber;
const int LaserData::kRangeFieldNumber;
const int LaserData::kIntensitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserData::LaserData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.LaserData)
}

void LaserData::InitAsDefaultInstance() {
}

LaserData::LaserData(const LaserData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.LaserData)
}

void LaserData::SharedCtor() {
  _cached_size_ = 0;
  angle_min_ = 0;
  angle_max_ = 0;
  angle_step_ = 0;
  range_min_ = 0;
  range_max_ = 0;
  count_ = 0;
  vertical_angle_min_ = 0;
  vertical_angle_max_ = 0;
  vertical_angle_step_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaserData::~LaserData() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.LaserData)
  SharedDtor();
}

void LaserData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaserData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaserData_descriptor_;
}

const LaserData& LaserData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

LaserData* LaserData::default_instance_ = NULL;

LaserData* LaserData::New(::google::protobuf::Arena* arena) const {
  LaserData* n = new LaserData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserData::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.LaserData)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LaserData, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LaserData*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(angle_min_, vertical_angle_max_);
  }
  vertical_angle_step_ = 0;

#undef ZR_HELPER_
#undef ZR_

  range_.Clear();
  intensities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaserData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.LaserData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double angle_min = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_min_)));
          set_has_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_angle_max;
        break;
      }

      // required double angle_max = 2;
      case 2: {
        if (tag == 17) {
         parse_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_max_)));
          set_has_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_angle_step;
        break;
      }

      // required double angle_step = 3;
      case 3: {
        if (tag == 25) {
         parse_angle_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_step_)));
          set_has_angle_step();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_range_min;
        break;
      }

      // required double range_min = 4;
      case 4: {
        if (tag == 33) {
         parse_range_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &range_min_)));
          set_has_range_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_range_max;
        break;
      }

      // required double range_max = 5;
      case 5: {
        if (tag == 41) {
         parse_range_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &range_max_)));
          set_has_range_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_count;
        break;
      }

      // required double count = 6;
      case 6: {
        if (tag == 49) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_vertical_angle_min;
        break;
      }

      // required double vertical_angle_min = 7;
      case 7: {
        if (tag == 57) {
         parse_vertical_angle_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_min_)));
          set_has_vertical_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_vertical_angle_max;
        break;
      }

      // required double vertical_angle_max = 8;
      case 8: {
        if (tag == 65) {
         parse_vertical_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_max_)));
          set_has_vertical_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_vertical_angle_step;
        break;
      }

      // required double vertical_angle_step = 9;
      case 9: {
        if (tag == 73) {
         parse_vertical_angle_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_step_)));
          set_has_vertical_angle_step();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_range;
        break;
      }

      // repeated double range = 10;
      case 10: {
        if (tag == 81) {
         parse_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 81, input, this->mutable_range())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_range())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_range;
        if (input->ExpectTag(89)) goto parse_intensities;
        break;
      }

      // repeated double intensities = 11;
      case 11: {
        if (tag == 89) {
         parse_intensities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 89, input, this->mutable_intensities())));
        } else if (tag == 90) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_intensities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_intensities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.LaserData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.LaserData)
  return false;
#undef DO_
}

void LaserData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.LaserData)
  // required double angle_min = 1;
  if (has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->angle_min(), output);
  }

  // required double angle_max = 2;
  if (has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->angle_max(), output);
  }

  // required double angle_step = 3;
  if (has_angle_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->angle_step(), output);
  }

  // required double range_min = 4;
  if (has_range_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->range_min(), output);
  }

  // required double range_max = 5;
  if (has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->range_max(), output);
  }

  // required double count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->count(), output);
  }

  // required double vertical_angle_min = 7;
  if (has_vertical_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->vertical_angle_min(), output);
  }

  // required double vertical_angle_max = 8;
  if (has_vertical_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->vertical_angle_max(), output);
  }

  // required double vertical_angle_step = 9;
  if (has_vertical_angle_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->vertical_angle_step(), output);
  }

  // repeated double range = 10;
  for (int i = 0; i < this->range_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      10, this->range(i), output);
  }

  // repeated double intensities = 11;
  for (int i = 0; i < this->intensities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      11, this->intensities(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.LaserData)
}

::google::protobuf::uint8* LaserData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.LaserData)
  // required double angle_min = 1;
  if (has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->angle_min(), target);
  }

  // required double angle_max = 2;
  if (has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->angle_max(), target);
  }

  // required double angle_step = 3;
  if (has_angle_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->angle_step(), target);
  }

  // required double range_min = 4;
  if (has_range_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->range_min(), target);
  }

  // required double range_max = 5;
  if (has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->range_max(), target);
  }

  // required double count = 6;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->count(), target);
  }

  // required double vertical_angle_min = 7;
  if (has_vertical_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->vertical_angle_min(), target);
  }

  // required double vertical_angle_max = 8;
  if (has_vertical_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->vertical_angle_max(), target);
  }

  // required double vertical_angle_step = 9;
  if (has_vertical_angle_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->vertical_angle_step(), target);
  }

  // repeated double range = 10;
  for (int i = 0; i < this->range_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(10, this->range(i), target);
  }

  // repeated double intensities = 11;
  for (int i = 0; i < this->intensities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(11, this->intensities(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.LaserData)
  return target;
}

int LaserData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.LaserData)
  int total_size = 0;

  if (has_angle_min()) {
    // required double angle_min = 1;
    total_size += 1 + 8;
  }

  if (has_angle_max()) {
    // required double angle_max = 2;
    total_size += 1 + 8;
  }

  if (has_angle_step()) {
    // required double angle_step = 3;
    total_size += 1 + 8;
  }

  if (has_range_min()) {
    // required double range_min = 4;
    total_size += 1 + 8;
  }

  if (has_range_max()) {
    // required double range_max = 5;
    total_size += 1 + 8;
  }

  if (has_count()) {
    // required double count = 6;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_min()) {
    // required double vertical_angle_min = 7;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_max()) {
    // required double vertical_angle_max = 8;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_step()) {
    // required double vertical_angle_step = 9;
    total_size += 1 + 8;
  }

  return total_size;
}
int LaserData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.LaserData)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000001ff) ^ 0x000001ff) == 0) {  // All required fields are present.
    // required double angle_min = 1;
    total_size += 1 + 8;

    // required double angle_max = 2;
    total_size += 1 + 8;

    // required double angle_step = 3;
    total_size += 1 + 8;

    // required double range_min = 4;
    total_size += 1 + 8;

    // required double range_max = 5;
    total_size += 1 + 8;

    // required double count = 6;
    total_size += 1 + 8;

    // required double vertical_angle_min = 7;
    total_size += 1 + 8;

    // required double vertical_angle_max = 8;
    total_size += 1 + 8;

    // required double vertical_angle_step = 9;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated double range = 10;
  {
    int data_size = 0;
    data_size = 8 * this->range_size();
    total_size += 1 * this->range_size() + data_size;
  }

  // repeated double intensities = 11;
  {
    int data_size = 0;
    data_size = 8 * this->intensities_size();
    total_size += 1 * this->intensities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.LaserData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LaserData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.LaserData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.LaserData)
    MergeFrom(*source);
  }
}

void LaserData::MergeFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.LaserData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  range_.MergeFrom(from.range_);
  intensities_.MergeFrom(from.intensities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_angle_min()) {
      set_angle_min(from.angle_min());
    }
    if (from.has_angle_max()) {
      set_angle_max(from.angle_max());
    }
    if (from.has_angle_step()) {
      set_angle_step(from.angle_step());
    }
    if (from.has_range_min()) {
      set_range_min(from.range_min());
    }
    if (from.has_range_max()) {
      set_range_max(from.range_max());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_vertical_angle_min()) {
      set_vertical_angle_min(from.vertical_angle_min());
    }
    if (from.has_vertical_angle_max()) {
      set_vertical_angle_max(from.vertical_angle_max());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_vertical_angle_step()) {
      set_vertical_angle_step(from.vertical_angle_step());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaserData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserData::CopyFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserData::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void LaserData::Swap(LaserData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserData::InternalSwap(LaserData* other) {
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_step_, other->angle_step_);
  std::swap(range_min_, other->range_min_);
  std::swap(range_max_, other->range_max_);
  std::swap(count_, other->count_);
  std::swap(vertical_angle_min_, other->vertical_angle_min_);
  std::swap(vertical_angle_max_, other->vertical_angle_max_);
  std::swap(vertical_angle_step_, other->vertical_angle_step_);
  range_.UnsafeArenaSwap(&other->range_);
  intensities_.UnsafeArenaSwap(&other->intensities_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaserData_descriptor_;
  metadata.reflection = LaserData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserData

// required double angle_min = 1;
bool LaserData::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaserData::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
void LaserData::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaserData::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
 double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_min)
  return angle_min_;
}
 void LaserData::set_angle_min(double value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_min)
}

// required double angle_max = 2;
bool LaserData::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaserData::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
void LaserData::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaserData::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
 double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_max)
  return angle_max_;
}
 void LaserData::set_angle_max(double value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_max)
}

// required double angle_step = 3;
bool LaserData::has_angle_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LaserData::set_has_angle_step() {
  _has_bits_[0] |= 0x00000004u;
}
void LaserData::clear_has_angle_step() {
  _has_bits_[0] &= ~0x00000004u;
}
void LaserData::clear_angle_step() {
  angle_step_ = 0;
  clear_has_angle_step();
}
 double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_step)
  return angle_step_;
}
 void LaserData::set_angle_step(double value) {
  set_has_angle_step();
  angle_step_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_step)
}

// required double range_min = 4;
bool LaserData::has_range_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LaserData::set_has_range_min() {
  _has_bits_[0] |= 0x00000008u;
}
void LaserData::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000008u;
}
void LaserData::clear_range_min() {
  range_min_ = 0;
  clear_has_range_min();
}
 double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range_min)
  return range_min_;
}
 void LaserData::set_range_min(double value) {
  set_has_range_min();
  range_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range_min)
}

// required double range_max = 5;
bool LaserData::has_range_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LaserData::set_has_range_max() {
  _has_bits_[0] |= 0x00000010u;
}
void LaserData::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000010u;
}
void LaserData::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
 double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range_max)
  return range_max_;
}
 void LaserData::set_range_max(double value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range_max)
}

// required double count = 6;
bool LaserData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LaserData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
void LaserData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
void LaserData::clear_count() {
  count_ = 0;
  clear_has_count();
}
 double LaserData::count() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.count)
  return count_;
}
 void LaserData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.count)
}

// required double vertical_angle_min = 7;
bool LaserData::has_vertical_angle_min() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LaserData::set_has_vertical_angle_min() {
  _has_bits_[0] |= 0x00000040u;
}
void LaserData::clear_has_vertical_angle_min() {
  _has_bits_[0] &= ~0x00000040u;
}
void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  clear_has_vertical_angle_min();
}
 double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_min)
  return vertical_angle_min_;
}
 void LaserData::set_vertical_angle_min(double value) {
  set_has_vertical_angle_min();
  vertical_angle_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_min)
}

// required double vertical_angle_max = 8;
bool LaserData::has_vertical_angle_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LaserData::set_has_vertical_angle_max() {
  _has_bits_[0] |= 0x00000080u;
}
void LaserData::clear_has_vertical_angle_max() {
  _has_bits_[0] &= ~0x00000080u;
}
void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  clear_has_vertical_angle_max();
}
 double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_max)
  return vertical_angle_max_;
}
 void LaserData::set_vertical_angle_max(double value) {
  set_has_vertical_angle_max();
  vertical_angle_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_max)
}

// required double vertical_angle_step = 9;
bool LaserData::has_vertical_angle_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void LaserData::set_has_vertical_angle_step() {
  _has_bits_[0] |= 0x00000100u;
}
void LaserData::clear_has_vertical_angle_step() {
  _has_bits_[0] &= ~0x00000100u;
}
void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  clear_has_vertical_angle_step();
}
 double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_step)
  return vertical_angle_step_;
}
 void LaserData::set_vertical_angle_step(double value) {
  set_has_vertical_angle_step();
  vertical_angle_step_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
int LaserData::range_size() const {
  return range_.size();
}
void LaserData::clear_range() {
  range_.Clear();
}
 double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range)
  return range_.Get(index);
}
 void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range)
}
 void LaserData::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.LaserData.range)
}
 const ::google::protobuf::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.LaserData.range)
  return range_;
}
 ::google::protobuf::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.LaserData.range)
  return &range_;
}

// repeated double intensities = 11;
int LaserData::intensities_size() const {
  return intensities_.size();
}
void LaserData::clear_intensities() {
  intensities_.Clear();
}
 double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.intensities)
  return intensities_.Get(index);
}
 void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.intensities)
}
 void LaserData::add_intensities(double value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.LaserData.intensities)
}
 const ::google::protobuf::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.LaserData.intensities)
  return intensities_;
}
 ::google::protobuf::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.LaserData.intensities)
  return &intensities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestLaser::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestLaser::RequestLaser()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.RequestLaser)
}

void RequestLaser::InitAsDefaultInstance() {
}

RequestLaser::RequestLaser(const RequestLaser& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.RequestLaser)
}

void RequestLaser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestLaser::~RequestLaser() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.RequestLaser)
  SharedDtor();
}

void RequestLaser::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestLaser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestLaser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestLaser_descriptor_;
}

const RequestLaser& RequestLaser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestLaser* RequestLaser::default_instance_ = NULL;

RequestLaser* RequestLaser::New(::google::protobuf::Arena* arena) const {
  RequestLaser* n = new RequestLaser;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.RequestLaser)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestLaser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.RequestLaser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.RequestLaser.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.RequestLaser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.RequestLaser)
  return false;
#undef DO_
}

void RequestLaser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.RequestLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestLaser.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.RequestLaser)
}

::google::protobuf::uint8* RequestLaser::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.RequestLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestLaser.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.RequestLaser)
  return target;
}

int RequestLaser::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.RequestLaser)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestLaser::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.RequestLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestLaser* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestLaser>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.RequestLaser)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.RequestLaser)
    MergeFrom(*source);
  }
}

void RequestLaser::MergeFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.RequestLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestLaser::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestLaser::CopyFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestLaser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestLaser::Swap(RequestLaser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestLaser::InternalSwap(RequestLaser* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestLaser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestLaser_descriptor_;
  metadata.reflection = RequestLaser_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestLaser

// required string topic_name = 1;
bool RequestLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestLaser.topic_name)
}
 void RequestLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestLaser.topic_name)
}
 void RequestLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestLaser.topic_name)
}
 ::std::string* RequestLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestLaser.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImuData::kLinearAccelerationFieldNumber;
const int ImuData::kAngularVelocityFieldNumber;
const int ImuData::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImuData::ImuData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ImuData)
}

void ImuData::InitAsDefaultInstance() {
  linear_acceleration_ = const_cast< ::robotics::gazebotransport::Point*>(&::robotics::gazebotransport::Point::default_instance());
  angular_velocity_ = const_cast< ::robotics::gazebotransport::Point*>(&::robotics::gazebotransport::Point::default_instance());
  orientation_ = const_cast< ::robotics::gazebotransport::Quaternion*>(&::robotics::gazebotransport::Quaternion::default_instance());
}

ImuData::ImuData(const ImuData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ImuData)
}

void ImuData::SharedCtor() {
  _cached_size_ = 0;
  linear_acceleration_ = NULL;
  angular_velocity_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImuData::~ImuData() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ImuData)
  SharedDtor();
}

void ImuData::SharedDtor() {
  if (this != default_instance_) {
    delete linear_acceleration_;
    delete angular_velocity_;
    delete orientation_;
  }
}

void ImuData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImuData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImuData_descriptor_;
}

const ImuData& ImuData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ImuData* ImuData::default_instance_ = NULL;

ImuData* ImuData::New(::google::protobuf::Arena* arena) const {
  ImuData* n = new ImuData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImuData::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ImuData)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_linear_acceleration()) {
      if (linear_acceleration_ != NULL) linear_acceleration_->::robotics::gazebotransport::Point::Clear();
    }
    if (has_angular_velocity()) {
      if (angular_velocity_ != NULL) angular_velocity_->::robotics::gazebotransport::Point::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ImuData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ImuData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.Point linear_acceleration = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linear_acceleration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angular_velocity;
        break;
      }

      // required .robotics.gazebotransport.Point angular_velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_angular_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angular_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_orientation;
        break;
      }

      // required .robotics.gazebotransport.Quaternion orientation = 3;
      case 3: {
        if (tag == 26) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ImuData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ImuData)
  return false;
#undef DO_
}

void ImuData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ImuData)
  // required .robotics.gazebotransport.Point linear_acceleration = 1;
  if (has_linear_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->linear_acceleration_, output);
  }

  // required .robotics.gazebotransport.Point angular_velocity = 2;
  if (has_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angular_velocity_, output);
  }

  // required .robotics.gazebotransport.Quaternion orientation = 3;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->orientation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ImuData)
}

::google::protobuf::uint8* ImuData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ImuData)
  // required .robotics.gazebotransport.Point linear_acceleration = 1;
  if (has_linear_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->linear_acceleration_, false, target);
  }

  // required .robotics.gazebotransport.Point angular_velocity = 2;
  if (has_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->angular_velocity_, false, target);
  }

  // required .robotics.gazebotransport.Quaternion orientation = 3;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->orientation_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ImuData)
  return target;
}

int ImuData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.ImuData)
  int total_size = 0;

  if (has_linear_acceleration()) {
    // required .robotics.gazebotransport.Point linear_acceleration = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->linear_acceleration_);
  }

  if (has_angular_velocity()) {
    // required .robotics.gazebotransport.Point angular_velocity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angular_velocity_);
  }

  if (has_orientation()) {
    // required .robotics.gazebotransport.Quaternion orientation = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);
  }

  return total_size;
}
int ImuData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ImuData)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .robotics.gazebotransport.Point linear_acceleration = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->linear_acceleration_);

    // required .robotics.gazebotransport.Point angular_velocity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angular_velocity_);

    // required .robotics.gazebotransport.Quaternion orientation = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImuData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ImuData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ImuData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ImuData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ImuData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ImuData)
    MergeFrom(*source);
  }
}

void ImuData::MergeFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ImuData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_linear_acceleration()) {
      mutable_linear_acceleration()->::robotics::gazebotransport::Point::MergeFrom(from.linear_acceleration());
    }
    if (from.has_angular_velocity()) {
      mutable_angular_velocity()->::robotics::gazebotransport::Point::MergeFrom(from.angular_velocity());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::robotics::gazebotransport::Quaternion::MergeFrom(from.orientation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ImuData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImuData::CopyFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_linear_acceleration()) {
    if (!this->linear_acceleration_->IsInitialized()) return false;
  }
  if (has_angular_velocity()) {
    if (!this->angular_velocity_->IsInitialized()) return false;
  }
  if (has_orientation()) {
    if (!this->orientation_->IsInitialized()) return false;
  }
  return true;
}

void ImuData::Swap(ImuData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImuData::InternalSwap(ImuData* other) {
  std::swap(linear_acceleration_, other->linear_acceleration_);
  std::swap(angular_velocity_, other->angular_velocity_);
  std::swap(orientation_, other->orientation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ImuData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImuData_descriptor_;
  metadata.reflection = ImuData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImuData

// required .robotics.gazebotransport.Point linear_acceleration = 1;
bool ImuData::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ImuData::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
void ImuData::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::robotics::gazebotransport::Point::Clear();
  clear_has_linear_acceleration();
}
const ::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_;
}
::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.linear_acceleration)
  clear_has_linear_acceleration();
  ::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
void ImuData::set_allocated_linear_acceleration(::robotics::gazebotransport::Point* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.linear_acceleration)
}

// required .robotics.gazebotransport.Point angular_velocity = 2;
bool ImuData::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ImuData::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
void ImuData::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::robotics::gazebotransport::Point::Clear();
  clear_has_angular_velocity();
}
const ::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_;
}
::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.angular_velocity)
  clear_has_angular_velocity();
  ::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
void ImuData::set_allocated_angular_velocity(::robotics::gazebotransport::Point* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.angular_velocity)
}

// required .robotics.gazebotransport.Quaternion orientation = 3;
bool ImuData::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ImuData::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
void ImuData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
void ImuData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
const ::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.orientation)
  return orientation_;
}
::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.orientation)
  clear_has_orientation();
  ::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void ImuData::set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestImu::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestImu::RequestImu()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.RequestImu)
}

void RequestImu::InitAsDefaultInstance() {
}

RequestImu::RequestImu(const RequestImu& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.RequestImu)
}

void RequestImu::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestImu::~RequestImu() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.RequestImu)
  SharedDtor();
}

void RequestImu::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestImu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestImu::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestImu_descriptor_;
}

const RequestImu& RequestImu::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestImu* RequestImu::default_instance_ = NULL;

RequestImu* RequestImu::New(::google::protobuf::Arena* arena) const {
  RequestImu* n = new RequestImu;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestImu::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.RequestImu)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestImu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.RequestImu)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.RequestImu.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.RequestImu)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.RequestImu)
  return false;
#undef DO_
}

void RequestImu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.RequestImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestImu.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.RequestImu)
}

::google::protobuf::uint8* RequestImu::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.RequestImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.RequestImu.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.RequestImu)
  return target;
}

int RequestImu::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.RequestImu)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestImu::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.RequestImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestImu* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestImu>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.RequestImu)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.RequestImu)
    MergeFrom(*source);
  }
}

void RequestImu::MergeFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.RequestImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestImu::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImu::CopyFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImu::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestImu::Swap(RequestImu* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestImu::InternalSwap(RequestImu* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestImu::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestImu_descriptor_;
  metadata.reflection = RequestImu_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestImu

// required string topic_name = 1;
bool RequestImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestImu.topic_name)
}
 void RequestImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestImu.topic_name)
}
 void RequestImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestImu.topic_name)
}
 ::std::string* RequestImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestImu.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeImage::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeImage::SubscribeImage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.SubscribeImage)
}

void SubscribeImage::InitAsDefaultInstance() {
}

SubscribeImage::SubscribeImage(const SubscribeImage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.SubscribeImage)
}

void SubscribeImage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeImage::~SubscribeImage() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.SubscribeImage)
  SharedDtor();
}

void SubscribeImage::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeImage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeImage_descriptor_;
}

const SubscribeImage& SubscribeImage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeImage* SubscribeImage::default_instance_ = NULL;

SubscribeImage* SubscribeImage::New(::google::protobuf::Arena* arena) const {
  SubscribeImage* n = new SubscribeImage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeImage::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.SubscribeImage)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.SubscribeImage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.SubscribeImage.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.SubscribeImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.SubscribeImage)
  return false;
#undef DO_
}

void SubscribeImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.SubscribeImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeImage.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.SubscribeImage)
}

::google::protobuf::uint8* SubscribeImage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.SubscribeImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeImage.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.SubscribeImage)
  return target;
}

int SubscribeImage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.SubscribeImage)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeImage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.SubscribeImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeImage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeImage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.SubscribeImage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.SubscribeImage)
    MergeFrom(*source);
  }
}

void SubscribeImage::MergeFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.SubscribeImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeImage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImage::CopyFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeImage::Swap(SubscribeImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeImage::InternalSwap(SubscribeImage* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeImage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeImage_descriptor_;
  metadata.reflection = SubscribeImage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeImage

// required string topic_name = 1;
bool SubscribeImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeImage.topic_name)
}
 void SubscribeImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeImage.topic_name)
}
 void SubscribeImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeImage.topic_name)
}
 ::std::string* SubscribeImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeImage.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeLaser::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeLaser::SubscribeLaser()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.SubscribeLaser)
}

void SubscribeLaser::InitAsDefaultInstance() {
}

SubscribeLaser::SubscribeLaser(const SubscribeLaser& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.SubscribeLaser)
}

void SubscribeLaser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeLaser::~SubscribeLaser() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.SubscribeLaser)
  SharedDtor();
}

void SubscribeLaser::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeLaser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeLaser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeLaser_descriptor_;
}

const SubscribeLaser& SubscribeLaser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeLaser* SubscribeLaser::default_instance_ = NULL;

SubscribeLaser* SubscribeLaser::New(::google::protobuf::Arena* arena) const {
  SubscribeLaser* n = new SubscribeLaser;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.SubscribeLaser)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeLaser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.SubscribeLaser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.SubscribeLaser.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.SubscribeLaser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.SubscribeLaser)
  return false;
#undef DO_
}

void SubscribeLaser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.SubscribeLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeLaser.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.SubscribeLaser)
}

::google::protobuf::uint8* SubscribeLaser::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.SubscribeLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeLaser.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.SubscribeLaser)
  return target;
}

int SubscribeLaser::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.SubscribeLaser)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeLaser::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.SubscribeLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeLaser* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeLaser>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.SubscribeLaser)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.SubscribeLaser)
    MergeFrom(*source);
  }
}

void SubscribeLaser::MergeFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.SubscribeLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeLaser::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeLaser::CopyFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeLaser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeLaser::Swap(SubscribeLaser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeLaser::InternalSwap(SubscribeLaser* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeLaser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeLaser_descriptor_;
  metadata.reflection = SubscribeLaser_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeLaser

// required string topic_name = 1;
bool SubscribeLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeLaser.topic_name)
}
 void SubscribeLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeLaser.topic_name)
}
 void SubscribeLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeLaser.topic_name)
}
 ::std::string* SubscribeLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeLaser.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeImu::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeImu::SubscribeImu()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.SubscribeImu)
}

void SubscribeImu::InitAsDefaultInstance() {
}

SubscribeImu::SubscribeImu(const SubscribeImu& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.SubscribeImu)
}

void SubscribeImu::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeImu::~SubscribeImu() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.SubscribeImu)
  SharedDtor();
}

void SubscribeImu::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeImu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeImu::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeImu_descriptor_;
}

const SubscribeImu& SubscribeImu::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeImu* SubscribeImu::default_instance_ = NULL;

SubscribeImu* SubscribeImu::New(::google::protobuf::Arena* arena) const {
  SubscribeImu* n = new SubscribeImu;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeImu::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.SubscribeImu)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeImu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.SubscribeImu)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.SubscribeImu.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.SubscribeImu)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.SubscribeImu)
  return false;
#undef DO_
}

void SubscribeImu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.SubscribeImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeImu.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.SubscribeImu)
}

::google::protobuf::uint8* SubscribeImu::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.SubscribeImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.SubscribeImu.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.SubscribeImu)
  return target;
}

int SubscribeImu::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.SubscribeImu)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeImu::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.SubscribeImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeImu* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeImu>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.SubscribeImu)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.SubscribeImu)
    MergeFrom(*source);
  }
}

void SubscribeImu::MergeFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.SubscribeImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeImu::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImu::CopyFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImu::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeImu::Swap(SubscribeImu* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeImu::InternalSwap(SubscribeImu* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeImu::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeImu_descriptor_;
  metadata.reflection = SubscribeImu_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeImu

// required string topic_name = 1;
bool SubscribeImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeImu.topic_name)
}
 void SubscribeImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeImu.topic_name)
}
 void SubscribeImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeImu.topic_name)
}
 ::std::string* SubscribeImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeImu.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplyLinkWrench::kModelNameFieldNumber;
const int ApplyLinkWrench::kLinkNameFieldNumber;
const int ApplyLinkWrench::kForceTypeFieldNumber;
const int ApplyLinkWrench::kFxFieldNumber;
const int ApplyLinkWrench::kFyFieldNumber;
const int ApplyLinkWrench::kFzFieldNumber;
const int ApplyLinkWrench::kTorqueTypeFieldNumber;
const int ApplyLinkWrench::kTxFieldNumber;
const int ApplyLinkWrench::kTyFieldNumber;
const int ApplyLinkWrench::kTzFieldNumber;
const int ApplyLinkWrench::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplyLinkWrench::ApplyLinkWrench()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ApplyLinkWrench)
}

void ApplyLinkWrench::InitAsDefaultInstance() {
  duration_ = const_cast< ::robotics::gazebotransport::Time*>(&::robotics::gazebotransport::Time::default_instance());
}

ApplyLinkWrench::ApplyLinkWrench(const ApplyLinkWrench& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ApplyLinkWrench)
}

void ApplyLinkWrench::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  force_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fx_ = 0;
  fy_ = 0;
  fz_ = 0;
  torque_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tx_ = 0;
  ty_ = 0;
  tz_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyLinkWrench::~ApplyLinkWrench() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ApplyLinkWrench)
  SharedDtor();
}

void ApplyLinkWrench::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  force_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  torque_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void ApplyLinkWrench::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplyLinkWrench::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplyLinkWrench_descriptor_;
}

const ApplyLinkWrench& ApplyLinkWrench::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ApplyLinkWrench* ApplyLinkWrench::default_instance_ = NULL;

ApplyLinkWrench* ApplyLinkWrench::New(::google::protobuf::Arena* arena) const {
  ApplyLinkWrench* n = new ApplyLinkWrench;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplyLinkWrench::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ApplyLinkWrench)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ApplyLinkWrench, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ApplyLinkWrench*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(fx_, fz_);
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_force_type()) {
      force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_torque_type()) {
      torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    tx_ = 0;
  }
  if (_has_bits_[8 / 32] & 1792u) {
    ZR_(ty_, tz_);
    if (has_duration()) {
      if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ApplyLinkWrench::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ApplyLinkWrench)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyLinkWrench.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyLinkWrench.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_force_type;
        break;
      }

      // required string force_type = 3;
      case 3: {
        if (tag == 26) {
         parse_force_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_force_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->force_type().data(), this->force_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyLinkWrench.force_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_fx;
        break;
      }

      // required double fx = 4;
      case 4: {
        if (tag == 33) {
         parse_fx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fx_)));
          set_has_fx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_fy;
        break;
      }

      // required double fy = 5;
      case 5: {
        if (tag == 41) {
         parse_fy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fy_)));
          set_has_fy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_fz;
        break;
      }

      // required double fz = 6;
      case 6: {
        if (tag == 49) {
         parse_fz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fz_)));
          set_has_fz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_torque_type;
        break;
      }

      // required string torque_type = 7;
      case 7: {
        if (tag == 58) {
         parse_torque_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_torque_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->torque_type().data(), this->torque_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyLinkWrench.torque_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_tx;
        break;
      }

      // required double tx = 8;
      case 8: {
        if (tag == 65) {
         parse_tx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tx_)));
          set_has_tx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_ty;
        break;
      }

      // required double ty = 9;
      case 9: {
        if (tag == 73) {
         parse_ty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ty_)));
          set_has_ty();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_tz;
        break;
      }

      // required double tz = 10;
      case 10: {
        if (tag == 81) {
         parse_tz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tz_)));
          set_has_tz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_duration;
        break;
      }

      // required .robotics.gazebotransport.Time duration = 11;
      case 11: {
        if (tag == 90) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ApplyLinkWrench)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ApplyLinkWrench)
  return false;
#undef DO_
}

void ApplyLinkWrench::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ApplyLinkWrench)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required string force_type = 3;
  if (has_force_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->force_type().data(), this->force_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.force_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->force_type(), output);
  }

  // required double fx = 4;
  if (has_fx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->fx(), output);
  }

  // required double fy = 5;
  if (has_fy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->fy(), output);
  }

  // required double fz = 6;
  if (has_fz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->fz(), output);
  }

  // required string torque_type = 7;
  if (has_torque_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->torque_type().data(), this->torque_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.torque_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->torque_type(), output);
  }

  // required double tx = 8;
  if (has_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->tx(), output);
  }

  // required double ty = 9;
  if (has_ty()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->ty(), output);
  }

  // required double tz = 10;
  if (has_tz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->tz(), output);
  }

  // required .robotics.gazebotransport.Time duration = 11;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ApplyLinkWrench)
}

::google::protobuf::uint8* ApplyLinkWrench::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ApplyLinkWrench)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required string force_type = 3;
  if (has_force_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->force_type().data(), this->force_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.force_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->force_type(), target);
  }

  // required double fx = 4;
  if (has_fx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->fx(), target);
  }

  // required double fy = 5;
  if (has_fy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->fy(), target);
  }

  // required double fz = 6;
  if (has_fz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->fz(), target);
  }

  // required string torque_type = 7;
  if (has_torque_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->torque_type().data(), this->torque_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyLinkWrench.torque_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->torque_type(), target);
  }

  // required double tx = 8;
  if (has_tx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->tx(), target);
  }

  // required double ty = 9;
  if (has_ty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->ty(), target);
  }

  // required double tz = 10;
  if (has_tz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->tz(), target);
  }

  // required .robotics.gazebotransport.Time duration = 11;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ApplyLinkWrench)
  return target;
}

int ApplyLinkWrench::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.ApplyLinkWrench)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_force_type()) {
    // required string force_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->force_type());
  }

  if (has_fx()) {
    // required double fx = 4;
    total_size += 1 + 8;
  }

  if (has_fy()) {
    // required double fy = 5;
    total_size += 1 + 8;
  }

  if (has_fz()) {
    // required double fz = 6;
    total_size += 1 + 8;
  }

  if (has_torque_type()) {
    // required string torque_type = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->torque_type());
  }

  if (has_tx()) {
    // required double tx = 8;
    total_size += 1 + 8;
  }

  if (has_ty()) {
    // required double ty = 9;
    total_size += 1 + 8;
  }

  if (has_tz()) {
    // required double tz = 10;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int ApplyLinkWrench::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ApplyLinkWrench)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000007ff) ^ 0x000007ff) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required string force_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->force_type());

    // required double fx = 4;
    total_size += 1 + 8;

    // required double fy = 5;
    total_size += 1 + 8;

    // required double fz = 6;
    total_size += 1 + 8;

    // required string torque_type = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->torque_type());

    // required double tx = 8;
    total_size += 1 + 8;

    // required double ty = 9;
    total_size += 1 + 8;

    // required double tz = 10;
    total_size += 1 + 8;

    // required .robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyLinkWrench::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ApplyLinkWrench)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ApplyLinkWrench* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ApplyLinkWrench>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ApplyLinkWrench)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ApplyLinkWrench)
    MergeFrom(*source);
  }
}

void ApplyLinkWrench::MergeFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ApplyLinkWrench)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_force_type()) {
      set_has_force_type();
      force_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.force_type_);
    }
    if (from.has_fx()) {
      set_fx(from.fx());
    }
    if (from.has_fy()) {
      set_fy(from.fy());
    }
    if (from.has_fz()) {
      set_fz(from.fz());
    }
    if (from.has_torque_type()) {
      set_has_torque_type();
      torque_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.torque_type_);
    }
    if (from.has_tx()) {
      set_tx(from.tx());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ty()) {
      set_ty(from.ty());
    }
    if (from.has_tz()) {
      set_tz(from.tz());
    }
    if (from.has_duration()) {
      mutable_duration()->::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ApplyLinkWrench::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyLinkWrench::CopyFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyLinkWrench::IsInitialized() const {
  if ((_has_bits_[0] & 0x000007ff) != 0x000007ff) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyLinkWrench::Swap(ApplyLinkWrench* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplyLinkWrench::InternalSwap(ApplyLinkWrench* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  force_type_.Swap(&other->force_type_);
  std::swap(fx_, other->fx_);
  std::swap(fy_, other->fy_);
  std::swap(fz_, other->fz_);
  torque_type_.Swap(&other->torque_type_);
  std::swap(tx_, other->tx_);
  std::swap(ty_, other->ty_);
  std::swap(tz_, other->tz_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ApplyLinkWrench::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplyLinkWrench_descriptor_;
  metadata.reflection = ApplyLinkWrench_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplyLinkWrench

// required string model_name = 1;
bool ApplyLinkWrench::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplyLinkWrench::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplyLinkWrench::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 void ApplyLinkWrench::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 void ApplyLinkWrench::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 ::std::string* ApplyLinkWrench::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
bool ApplyLinkWrench::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplyLinkWrench::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplyLinkWrench::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 void ApplyLinkWrench::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 void ApplyLinkWrench::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 ::std::string* ApplyLinkWrench::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
bool ApplyLinkWrench::has_force_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ApplyLinkWrench::set_has_force_type() {
  _has_bits_[0] |= 0x00000004u;
}
void ApplyLinkWrench::clear_has_force_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_force_type();
}
 const ::std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_force_type(const ::std::string& value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 void ApplyLinkWrench::set_force_type(const char* value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 void ApplyLinkWrench::set_force_type(const char* value, size_t size) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 ::std::string* ApplyLinkWrench::mutable_force_type() {
  set_has_force_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.force_type)
  clear_has_force_type();
  return force_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_force_type(::std::string* force_type) {
  if (force_type != NULL) {
    set_has_force_type();
  } else {
    clear_has_force_type();
  }
  force_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), force_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
bool ApplyLinkWrench::has_fx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ApplyLinkWrench::set_has_fx() {
  _has_bits_[0] |= 0x00000008u;
}
void ApplyLinkWrench::clear_has_fx() {
  _has_bits_[0] &= ~0x00000008u;
}
void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  clear_has_fx();
}
 double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fx)
  return fx_;
}
 void ApplyLinkWrench::set_fx(double value) {
  set_has_fx();
  fx_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
bool ApplyLinkWrench::has_fy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ApplyLinkWrench::set_has_fy() {
  _has_bits_[0] |= 0x00000010u;
}
void ApplyLinkWrench::clear_has_fy() {
  _has_bits_[0] &= ~0x00000010u;
}
void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  clear_has_fy();
}
 double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fy)
  return fy_;
}
 void ApplyLinkWrench::set_fy(double value) {
  set_has_fy();
  fy_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
bool ApplyLinkWrench::has_fz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ApplyLinkWrench::set_has_fz() {
  _has_bits_[0] |= 0x00000020u;
}
void ApplyLinkWrench::clear_has_fz() {
  _has_bits_[0] &= ~0x00000020u;
}
void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  clear_has_fz();
}
 double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fz)
  return fz_;
}
 void ApplyLinkWrench::set_fz(double value) {
  set_has_fz();
  fz_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
bool ApplyLinkWrench::has_torque_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ApplyLinkWrench::set_has_torque_type() {
  _has_bits_[0] |= 0x00000040u;
}
void ApplyLinkWrench::clear_has_torque_type() {
  _has_bits_[0] &= ~0x00000040u;
}
void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_torque_type();
}
 const ::std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_torque_type(const ::std::string& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 void ApplyLinkWrench::set_torque_type(const char* value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 void ApplyLinkWrench::set_torque_type(const char* value, size_t size) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 ::std::string* ApplyLinkWrench::mutable_torque_type() {
  set_has_torque_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  clear_has_torque_type();
  return torque_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_torque_type(::std::string* torque_type) {
  if (torque_type != NULL) {
    set_has_torque_type();
  } else {
    clear_has_torque_type();
  }
  torque_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), torque_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
bool ApplyLinkWrench::has_tx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ApplyLinkWrench::set_has_tx() {
  _has_bits_[0] |= 0x00000080u;
}
void ApplyLinkWrench::clear_has_tx() {
  _has_bits_[0] &= ~0x00000080u;
}
void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
 double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.tx)
  return tx_;
}
 void ApplyLinkWrench::set_tx(double value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
bool ApplyLinkWrench::has_ty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ApplyLinkWrench::set_has_ty() {
  _has_bits_[0] |= 0x00000100u;
}
void ApplyLinkWrench::clear_has_ty() {
  _has_bits_[0] &= ~0x00000100u;
}
void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
 double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.ty)
  return ty_;
}
 void ApplyLinkWrench::set_ty(double value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
bool ApplyLinkWrench::has_tz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ApplyLinkWrench::set_has_tz() {
  _has_bits_[0] |= 0x00000200u;
}
void ApplyLinkWrench::clear_has_tz() {
  _has_bits_[0] &= ~0x00000200u;
}
void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
 double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.tz)
  return tz_;
}
 void ApplyLinkWrench::set_tz(double value) {
  set_has_tz();
  tz_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .robotics.gazebotransport.Time duration = 11;
bool ApplyLinkWrench::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ApplyLinkWrench::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
void ApplyLinkWrench::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
void ApplyLinkWrench::clear_duration() {
  if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_;
}
::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.duration)
  clear_has_duration();
  ::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void ApplyLinkWrench::set_allocated_duration(::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplyJointTorque::kModelNameFieldNumber;
const int ApplyJointTorque::kJointNameFieldNumber;
const int ApplyJointTorque::kIndexFieldNumber;
const int ApplyJointTorque::kEffortFieldNumber;
const int ApplyJointTorque::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplyJointTorque::ApplyJointTorque()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ApplyJointTorque)
}

void ApplyJointTorque::InitAsDefaultInstance() {
  duration_ = const_cast< ::robotics::gazebotransport::Time*>(&::robotics::gazebotransport::Time::default_instance());
}

ApplyJointTorque::ApplyJointTorque(const ApplyJointTorque& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ApplyJointTorque)
}

void ApplyJointTorque::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  effort_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyJointTorque::~ApplyJointTorque() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ApplyJointTorque)
  SharedDtor();
}

void ApplyJointTorque::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void ApplyJointTorque::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplyJointTorque::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplyJointTorque_descriptor_;
}

const ApplyJointTorque& ApplyJointTorque::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ApplyJointTorque* ApplyJointTorque::default_instance_ = NULL;

ApplyJointTorque* ApplyJointTorque::New(::google::protobuf::Arena* arena) const {
  ApplyJointTorque* n = new ApplyJointTorque;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplyJointTorque::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ApplyJointTorque)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    index_ = 0u;
    effort_ = 0;
    if (has_duration()) {
      if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ApplyJointTorque::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ApplyJointTorque)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyJointTorque.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ApplyJointTorque.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_effort;
        break;
      }

      // required double effort = 4;
      case 4: {
        if (tag == 33) {
         parse_effort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &effort_)));
          set_has_effort();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_duration;
        break;
      }

      // required .robotics.gazebotransport.Time duration = 5;
      case 5: {
        if (tag == 42) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ApplyJointTorque)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ApplyJointTorque)
  return false;
#undef DO_
}

void ApplyJointTorque::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ApplyJointTorque)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyJointTorque.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyJointTorque.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  // required uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // required double effort = 4;
  if (has_effort()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->effort(), output);
  }

  // required .robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ApplyJointTorque)
}

::google::protobuf::uint8* ApplyJointTorque::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ApplyJointTorque)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyJointTorque.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ApplyJointTorque.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  // required uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // required double effort = 4;
  if (has_effort()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->effort(), target);
  }

  // required .robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ApplyJointTorque)
  return target;
}

int ApplyJointTorque::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.ApplyJointTorque)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  if (has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  if (has_effort()) {
    // required double effort = 4;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int ApplyJointTorque::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ApplyJointTorque)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

    // required double effort = 4;
    total_size += 1 + 8;

    // required .robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyJointTorque::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ApplyJointTorque)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ApplyJointTorque* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ApplyJointTorque>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ApplyJointTorque)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ApplyJointTorque)
    MergeFrom(*source);
  }
}

void ApplyJointTorque::MergeFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ApplyJointTorque)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_effort()) {
      set_effort(from.effort());
    }
    if (from.has_duration()) {
      mutable_duration()->::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ApplyJointTorque::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyJointTorque::CopyFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyJointTorque::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyJointTorque::Swap(ApplyJointTorque* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplyJointTorque::InternalSwap(ApplyJointTorque* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(index_, other->index_);
  std::swap(effort_, other->effort_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ApplyJointTorque::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplyJointTorque_descriptor_;
  metadata.reflection = ApplyJointTorque_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplyJointTorque

// required string model_name = 1;
bool ApplyJointTorque::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplyJointTorque::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplyJointTorque::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.model_name)
}
 void ApplyJointTorque::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyJointTorque.model_name)
}
 void ApplyJointTorque::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyJointTorque.model_name)
}
 ::std::string* ApplyJointTorque::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
bool ApplyJointTorque::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplyJointTorque::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplyJointTorque::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 void ApplyJointTorque::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 void ApplyJointTorque::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 ::std::string* ApplyJointTorque::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
bool ApplyJointTorque::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ApplyJointTorque::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void ApplyJointTorque::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void ApplyJointTorque::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.index)
  return index_;
}
 void ApplyJointTorque::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
bool ApplyJointTorque::has_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ApplyJointTorque::set_has_effort() {
  _has_bits_[0] |= 0x00000008u;
}
void ApplyJointTorque::clear_has_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  clear_has_effort();
}
 double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.effort)
  return effort_;
}
 void ApplyJointTorque::set_effort(double value) {
  set_has_effort();
  effort_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .robotics.gazebotransport.Time duration = 5;
bool ApplyJointTorque::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ApplyJointTorque::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
void ApplyJointTorque::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
void ApplyJointTorque::clear_duration() {
  if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_;
}
::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.duration)
  clear_has_duration();
  ::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void ApplyJointTorque::set_allocated_duration(::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetPose::kModelNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetPose::GetPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.GetPose)
}

void GetPose::InitAsDefaultInstance() {
}

GetPose::GetPose(const GetPose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.GetPose)
}

void GetPose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPose::~GetPose() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.GetPose)
  SharedDtor();
}

void GetPose::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPose_descriptor_;
}

const GetPose& GetPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetPose* GetPose::default_instance_ = NULL;

GetPose* GetPose::New(::google::protobuf::Arena* arena) const {
  GetPose* n = new GetPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetPose::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.GetPose)
  if (has_model_name()) {
    model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.GetPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.GetPose.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.GetPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.GetPose)
  return false;
#undef DO_
}

void GetPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.GetPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetPose.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.GetPose)
}

::google::protobuf::uint8* GetPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.GetPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetPose.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.GetPose)
  return target;
}

int GetPose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.GetPose)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.GetPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetPose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.GetPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.GetPose)
    MergeFrom(*source);
  }
}

void GetPose::MergeFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.GetPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPose::CopyFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetPose::Swap(GetPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetPose::InternalSwap(GetPose* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPose_descriptor_;
  metadata.reflection = GetPose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetPose

// required string model_name = 1;
bool GetPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetPose.model_name)
}
 void GetPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetPose.model_name)
}
 void GetPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetPose.model_name)
}
 ::std::string* GetPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetPose.model_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetTopicList::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetTopicList::GetTopicList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.GetTopicList)
}

void GetTopicList::InitAsDefaultInstance() {
}

GetTopicList::GetTopicList(const GetTopicList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.GetTopicList)
}

void GetTopicList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTopicList::~GetTopicList() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.GetTopicList)
  SharedDtor();
}

void GetTopicList::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetTopicList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetTopicList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetTopicList_descriptor_;
}

const GetTopicList& GetTopicList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetTopicList* GetTopicList::default_instance_ = NULL;

GetTopicList* GetTopicList::New(::google::protobuf::Arena* arena) const {
  GetTopicList* n = new GetTopicList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetTopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.GetTopicList)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetTopicList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.GetTopicList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.GetTopicList.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.GetTopicList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.GetTopicList)
  return false;
#undef DO_
}

void GetTopicList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.GetTopicList)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetTopicList.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.GetTopicList)
}

::google::protobuf::uint8* GetTopicList::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.GetTopicList)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetTopicList.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.GetTopicList)
  return target;
}

int GetTopicList::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.GetTopicList)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTopicList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.GetTopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetTopicList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetTopicList>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.GetTopicList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.GetTopicList)
    MergeFrom(*source);
  }
}

void GetTopicList::MergeFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.GetTopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetTopicList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetTopicList::CopyFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTopicList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetTopicList::Swap(GetTopicList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetTopicList::InternalSwap(GetTopicList* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetTopicList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetTopicList_descriptor_;
  metadata.reflection = GetTopicList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetTopicList

// required string topic_name = 1;
bool GetTopicList::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetTopicList::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetTopicList::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetTopicList::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetTopicList.topic_name)
}
 void GetTopicList::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetTopicList.topic_name)
}
 void GetTopicList::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetTopicList.topic_name)
}
 ::std::string* GetTopicList::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetTopicList.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetTopicList::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetTopicList.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TopicList_TopicInfo::kNameFieldNumber;
const int TopicList_TopicInfo::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TopicList_TopicInfo::TopicList_TopicInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.TopicList.TopicInfo)
}

void TopicList_TopicInfo::InitAsDefaultInstance() {
}

TopicList_TopicInfo::TopicList_TopicInfo(const TopicList_TopicInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.TopicList.TopicInfo)
}

void TopicList_TopicInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopicList_TopicInfo::~TopicList_TopicInfo() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.TopicList.TopicInfo)
  SharedDtor();
}

void TopicList_TopicInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void TopicList_TopicInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TopicList_TopicInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TopicList_TopicInfo_descriptor_;
}

const TopicList_TopicInfo& TopicList_TopicInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

TopicList_TopicInfo* TopicList_TopicInfo::default_instance_ = NULL;

TopicList_TopicInfo* TopicList_TopicInfo::New(::google::protobuf::Arena* arena) const {
  TopicList_TopicInfo* n = new TopicList_TopicInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TopicList_TopicInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.TopicList.TopicInfo)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TopicList_TopicInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.TopicList.TopicInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.TopicList.TopicInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type;
        break;
      }

      // required string type = 2;
      case 2: {
        if (tag == 18) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.TopicList.TopicInfo.type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.TopicList.TopicInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.TopicList.TopicInfo)
  return false;
#undef DO_
}

void TopicList_TopicInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.TopicList.TopicInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.TopicList.TopicInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.TopicList.TopicInfo.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.TopicList.TopicInfo)
}

::google::protobuf::uint8* TopicList_TopicInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.TopicList.TopicInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.TopicList.TopicInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.TopicList.TopicInfo.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.TopicList.TopicInfo)
  return target;
}

int TopicList_TopicInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.TopicList.TopicInfo)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_type()) {
    // required string type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  return total_size;
}
int TopicList_TopicInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.TopicList.TopicInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required string type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopicList_TopicInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.TopicList.TopicInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TopicList_TopicInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TopicList_TopicInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.TopicList.TopicInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.TopicList.TopicInfo)
    MergeFrom(*source);
  }
}

void TopicList_TopicInfo::MergeFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.TopicList.TopicInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TopicList_TopicInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList_TopicInfo::CopyFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList_TopicInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TopicList_TopicInfo::Swap(TopicList_TopicInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TopicList_TopicInfo::InternalSwap(TopicList_TopicInfo* other) {
  name_.Swap(&other->name_);
  type_.Swap(&other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TopicList_TopicInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TopicList_TopicInfo_descriptor_;
  metadata.reflection = TopicList_TopicInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TopicList::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TopicList::TopicList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.TopicList)
}

void TopicList::InitAsDefaultInstance() {
}

TopicList::TopicList(const TopicList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.TopicList)
}

void TopicList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopicList::~TopicList() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.TopicList)
  SharedDtor();
}

void TopicList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TopicList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TopicList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TopicList_descriptor_;
}

const TopicList& TopicList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

TopicList* TopicList::default_instance_ = NULL;

TopicList* TopicList::New(::google::protobuf::Arena* arena) const {
  TopicList* n = new TopicList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.TopicList)
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TopicList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.TopicList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_data;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.TopicList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.TopicList)
  return false;
#undef DO_
}

void TopicList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.TopicList)
  // repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->data(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.TopicList)
}

::google::protobuf::uint8* TopicList::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.TopicList)
  // repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->data(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.TopicList)
  return target;
}

int TopicList::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.TopicList)
  int total_size = 0;

  // repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopicList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.TopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TopicList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TopicList>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.TopicList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.TopicList)
    MergeFrom(*source);
  }
}

void TopicList::MergeFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.TopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  data_.MergeFrom(from.data_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TopicList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList::CopyFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void TopicList::Swap(TopicList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TopicList::InternalSwap(TopicList* other) {
  data_.UnsafeArenaSwap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TopicList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TopicList_descriptor_;
  metadata.reflection = TopicList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TopicList_TopicInfo

// required string name = 1;
bool TopicList_TopicInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TopicList_TopicInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TopicList_TopicInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.TopicList.TopicInfo.name)
}
 void TopicList_TopicInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.TopicList.TopicInfo.name)
}
 void TopicList_TopicInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.TopicList.TopicInfo.name)
}
 ::std::string* TopicList_TopicInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.TopicList.TopicInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
bool TopicList_TopicInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TopicList_TopicInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TopicList_TopicInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.TopicList.TopicInfo.type)
}
 void TopicList_TopicInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.TopicList.TopicInfo.type)
}
 void TopicList_TopicInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.TopicList.TopicInfo.type)
}
 ::std::string* TopicList_TopicInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.TopicList.TopicInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
int TopicList::data_size() const {
  return data_.size();
}
void TopicList::clear_data() {
  data_.Clear();
}
const ::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.data)
  return data_.Get(index);
}
::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.TopicList.data)
  return data_.Add();
}
::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.TopicList.data)
  return &data_;
}
const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.TopicList.data)
  return data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetModelInfo::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetModelInfo::GetModelInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.GetModelInfo)
}

void GetModelInfo::InitAsDefaultInstance() {
}

GetModelInfo::GetModelInfo(const GetModelInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.GetModelInfo)
}

void GetModelInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetModelInfo::~GetModelInfo() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.GetModelInfo)
  SharedDtor();
}

void GetModelInfo::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetModelInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetModelInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetModelInfo_descriptor_;
}

const GetModelInfo& GetModelInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetModelInfo* GetModelInfo::default_instance_ = NULL;

GetModelInfo* GetModelInfo::New(::google::protobuf::Arena* arena) const {
  GetModelInfo* n = new GetModelInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.GetModelInfo)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetModelInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.GetModelInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.GetModelInfo.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.GetModelInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.GetModelInfo)
  return false;
#undef DO_
}

void GetModelInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.GetModelInfo)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetModelInfo.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.GetModelInfo)
}

::google::protobuf::uint8* GetModelInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.GetModelInfo)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.GetModelInfo.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.GetModelInfo)
  return target;
}

int GetModelInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.GetModelInfo)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetModelInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.GetModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetModelInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetModelInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.GetModelInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.GetModelInfo)
    MergeFrom(*source);
  }
}

void GetModelInfo::MergeFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.GetModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetModelInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetModelInfo::CopyFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetModelInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetModelInfo::Swap(GetModelInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetModelInfo::InternalSwap(GetModelInfo* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetModelInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetModelInfo_descriptor_;
  metadata.reflection = GetModelInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetModelInfo

// required string topic_name = 1;
bool GetModelInfo::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetModelInfo::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetModelInfo::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetModelInfo::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetModelInfo.topic_name)
}
 void GetModelInfo::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetModelInfo.topic_name)
}
 void GetModelInfo::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetModelInfo.topic_name)
}
 ::std::string* GetModelInfo::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetModelInfo.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetModelInfo::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetModelInfo.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_LINKS::kLinkNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_LINKS::ModelInfo_LINKS()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ModelInfo.LINKS)
}

void ModelInfo_LINKS::InitAsDefaultInstance() {
}

ModelInfo_LINKS::ModelInfo_LINKS(const ModelInfo_LINKS& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ModelInfo.LINKS)
}

void ModelInfo_LINKS::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_LINKS::~ModelInfo_LINKS() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ModelInfo.LINKS)
  SharedDtor();
}

void ModelInfo_LINKS::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo_LINKS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_LINKS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_LINKS_descriptor_;
}

const ModelInfo_LINKS& ModelInfo_LINKS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_LINKS* ModelInfo_LINKS::default_instance_ = NULL;

ModelInfo_LINKS* ModelInfo_LINKS::New(::google::protobuf::Arena* arena) const {
  ModelInfo_LINKS* n = new ModelInfo_LINKS;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_LINKS::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ModelInfo.LINKS)
  link_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_LINKS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ModelInfo.LINKS)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string link_name = 1;
      case 1: {
        if (tag == 10) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name(this->link_name_size() - 1).data(),
            this->link_name(this->link_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ModelInfo.LINKS.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_link_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ModelInfo.LINKS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ModelInfo.LINKS)
  return false;
#undef DO_
}

void ModelInfo_LINKS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ModelInfo.LINKS)
  // repeated string link_name = 1;
  for (int i = 0; i < this->link_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name(i).data(), this->link_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.LINKS.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->link_name(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ModelInfo.LINKS)
}

::google::protobuf::uint8* ModelInfo_LINKS::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ModelInfo.LINKS)
  // repeated string link_name = 1;
  for (int i = 0; i < this->link_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name(i).data(), this->link_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.LINKS.link_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->link_name(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ModelInfo.LINKS)
  return target;
}

int ModelInfo_LINKS::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ModelInfo.LINKS)
  int total_size = 0;

  // repeated string link_name = 1;
  total_size += 1 * this->link_name_size();
  for (int i = 0; i < this->link_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->link_name(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_LINKS::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ModelInfo.LINKS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_LINKS* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_LINKS>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ModelInfo.LINKS)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ModelInfo.LINKS)
    MergeFrom(*source);
  }
}

void ModelInfo_LINKS::MergeFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ModelInfo.LINKS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  link_name_.MergeFrom(from.link_name_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_LINKS::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_LINKS::CopyFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_LINKS::IsInitialized() const {

  return true;
}

void ModelInfo_LINKS::Swap(ModelInfo_LINKS* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_LINKS::InternalSwap(ModelInfo_LINKS* other) {
  link_name_.UnsafeArenaSwap(&other->link_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_LINKS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_LINKS_descriptor_;
  metadata.reflection = ModelInfo_LINKS_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_JOINTS::kJointNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_JOINTS::ModelInfo_JOINTS()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ModelInfo.JOINTS)
}

void ModelInfo_JOINTS::InitAsDefaultInstance() {
}

ModelInfo_JOINTS::ModelInfo_JOINTS(const ModelInfo_JOINTS& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ModelInfo.JOINTS)
}

void ModelInfo_JOINTS::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_JOINTS::~ModelInfo_JOINTS() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ModelInfo.JOINTS)
  SharedDtor();
}

void ModelInfo_JOINTS::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo_JOINTS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_JOINTS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_JOINTS_descriptor_;
}

const ModelInfo_JOINTS& ModelInfo_JOINTS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_JOINTS* ModelInfo_JOINTS::default_instance_ = NULL;

ModelInfo_JOINTS* ModelInfo_JOINTS::New(::google::protobuf::Arena* arena) const {
  ModelInfo_JOINTS* n = new ModelInfo_JOINTS;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_JOINTS::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ModelInfo.JOINTS)
  joint_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_JOINTS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ModelInfo.JOINTS)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string joint_name = 1;
      case 1: {
        if (tag == 10) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name(this->joint_name_size() - 1).data(),
            this->joint_name(this->joint_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_joint_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ModelInfo.JOINTS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ModelInfo.JOINTS)
  return false;
#undef DO_
}

void ModelInfo_JOINTS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ModelInfo.JOINTS)
  // repeated string joint_name = 1;
  for (int i = 0; i < this->joint_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name(i).data(), this->joint_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->joint_name(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ModelInfo.JOINTS)
}

::google::protobuf::uint8* ModelInfo_JOINTS::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ModelInfo.JOINTS)
  // repeated string joint_name = 1;
  for (int i = 0; i < this->joint_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name(i).data(), this->joint_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->joint_name(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ModelInfo.JOINTS)
  return target;
}

int ModelInfo_JOINTS::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ModelInfo.JOINTS)
  int total_size = 0;

  // repeated string joint_name = 1;
  total_size += 1 * this->joint_name_size();
  for (int i = 0; i < this->joint_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->joint_name(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_JOINTS::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ModelInfo.JOINTS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_JOINTS* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_JOINTS>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ModelInfo.JOINTS)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ModelInfo.JOINTS)
    MergeFrom(*source);
  }
}

void ModelInfo_JOINTS::MergeFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ModelInfo.JOINTS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  joint_name_.MergeFrom(from.joint_name_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_JOINTS::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_JOINTS::CopyFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_JOINTS::IsInitialized() const {

  return true;
}

void ModelInfo_JOINTS::Swap(ModelInfo_JOINTS* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_JOINTS::InternalSwap(ModelInfo_JOINTS* other) {
  joint_name_.UnsafeArenaSwap(&other->joint_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_JOINTS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_JOINTS_descriptor_;
  metadata.reflection = ModelInfo_JOINTS_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_Model::kModelNameFieldNumber;
const int ModelInfo_Model::kLinksFieldNumber;
const int ModelInfo_Model::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_Model::ModelInfo_Model()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ModelInfo.Model)
}

void ModelInfo_Model::InitAsDefaultInstance() {
  links_ = const_cast< ::robotics::gazebotransport::ModelInfo_LINKS*>(&::robotics::gazebotransport::ModelInfo_LINKS::default_instance());
  joints_ = const_cast< ::robotics::gazebotransport::ModelInfo_JOINTS*>(&::robotics::gazebotransport::ModelInfo_JOINTS::default_instance());
}

ModelInfo_Model::ModelInfo_Model(const ModelInfo_Model& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ModelInfo.Model)
}

void ModelInfo_Model::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  links_ = NULL;
  joints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_Model::~ModelInfo_Model() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ModelInfo.Model)
  SharedDtor();
}

void ModelInfo_Model::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete links_;
    delete joints_;
  }
}

void ModelInfo_Model::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_Model::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_Model_descriptor_;
}

const ModelInfo_Model& ModelInfo_Model::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_Model* ModelInfo_Model::default_instance_ = NULL;

ModelInfo_Model* ModelInfo_Model::New(::google::protobuf::Arena* arena) const {
  ModelInfo_Model* n = new ModelInfo_Model;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_Model::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ModelInfo.Model)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_links()) {
      if (links_ != NULL) links_->::robotics::gazebotransport::ModelInfo_LINKS::Clear();
    }
    if (has_joints()) {
      if (joints_ != NULL) joints_->::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_Model::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ModelInfo.Model)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robotics.gazebotransport.ModelInfo.Model.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_links;
        break;
      }

      // optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
      case 2: {
        if (tag == 18) {
         parse_links:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_links()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_joints;
        break;
      }

      // optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
      case 3: {
        if (tag == 26) {
         parse_joints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ModelInfo.Model)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ModelInfo.Model)
  return false;
#undef DO_
}

void ModelInfo_Model::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ModelInfo.Model)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.Model.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
  if (has_links()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->links_, output);
  }

  // optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->joints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ModelInfo.Model)
}

::google::protobuf::uint8* ModelInfo_Model::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ModelInfo.Model)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robotics.gazebotransport.ModelInfo.Model.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
  if (has_links()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->links_, false, target);
  }

  // optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->joints_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ModelInfo.Model)
  return target;
}

int ModelInfo_Model::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ModelInfo.Model)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
    if (has_links()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->links_);
    }

    // optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->joints_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_Model::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ModelInfo.Model)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_Model* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_Model>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ModelInfo.Model)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ModelInfo.Model)
    MergeFrom(*source);
  }
}

void ModelInfo_Model::MergeFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ModelInfo.Model)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_links()) {
      mutable_links()->::robotics::gazebotransport::ModelInfo_LINKS::MergeFrom(from.links());
    }
    if (from.has_joints()) {
      mutable_joints()->::robotics::gazebotransport::ModelInfo_JOINTS::MergeFrom(from.joints());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_Model::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_Model::CopyFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_Model::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ModelInfo_Model::Swap(ModelInfo_Model* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_Model::InternalSwap(ModelInfo_Model* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(links_, other->links_);
  std::swap(joints_, other->joints_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_Model::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_Model_descriptor_;
  metadata.reflection = ModelInfo_Model_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo::kModelDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo::ModelInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.ModelInfo)
}

void ModelInfo::InitAsDefaultInstance() {
}

ModelInfo::ModelInfo(const ModelInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.ModelInfo)
}

void ModelInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo::~ModelInfo() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.ModelInfo)
  SharedDtor();
}

void ModelInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_descriptor_;
}

const ModelInfo& ModelInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo* ModelInfo::default_instance_ = NULL;

ModelInfo* ModelInfo::New(::google::protobuf::Arena* arena) const {
  ModelInfo* n = new ModelInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.ModelInfo)
  model_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.ModelInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_model_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_model_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_model_data;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.ModelInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.ModelInfo)
  return false;
#undef DO_
}

void ModelInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.ModelInfo)
  // repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
  for (unsigned int i = 0, n = this->model_data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->model_data(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.ModelInfo)
}

::google::protobuf::uint8* ModelInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.ModelInfo)
  // repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
  for (unsigned int i = 0, n = this->model_data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->model_data(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.ModelInfo)
  return target;
}

int ModelInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.ModelInfo)
  int total_size = 0;

  // repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
  total_size += 1 * this->model_data_size();
  for (int i = 0; i < this->model_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->model_data(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.ModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.ModelInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.ModelInfo)
    MergeFrom(*source);
  }
}

void ModelInfo::MergeFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.ModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  model_data_.MergeFrom(from.model_data_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo::CopyFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->model_data())) return false;
  return true;
}

void ModelInfo::Swap(ModelInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo::InternalSwap(ModelInfo* other) {
  model_data_.UnsafeArenaSwap(&other->model_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_descriptor_;
  metadata.reflection = ModelInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ModelInfo_LINKS

// repeated string link_name = 1;
int ModelInfo_LINKS::link_name_size() const {
  return link_name_.size();
}
void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
 const ::std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Get(index);
}
 ::std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
 void ModelInfo_LINKS::set_link_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
 void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 ::std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Add();
}
 void ModelInfo_LINKS::add_link_name(const ::std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::add_link_name(const char* value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
int ModelInfo_JOINTS::joint_name_size() const {
  return joint_name_.size();
}
void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
 const ::std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Get(index);
}
 ::std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
 void ModelInfo_JOINTS::set_joint_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
 void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 ::std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Add();
}
 void ModelInfo_JOINTS::add_joint_name(const ::std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::add_joint_name(const char* value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
bool ModelInfo_Model::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ModelInfo_Model::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ModelInfo_Model::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ModelInfo_Model::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.Model.model_name)
}
 void ModelInfo_Model::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.Model.model_name)
}
 void ModelInfo_Model::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.Model.model_name)
}
 ::std::string* ModelInfo_Model::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ModelInfo_Model::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
bool ModelInfo_Model::has_links() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ModelInfo_Model::set_has_links() {
  _has_bits_[0] |= 0x00000002u;
}
void ModelInfo_Model::clear_has_links() {
  _has_bits_[0] &= ~0x00000002u;
}
void ModelInfo_Model::clear_links() {
  if (links_ != NULL) links_->::robotics::gazebotransport::ModelInfo_LINKS::Clear();
  clear_has_links();
}
const ::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.links)
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::robotics::gazebotransport::ModelInfo_LINKS;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.links)
  return links_;
}
::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.links)
  clear_has_links();
  ::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = NULL;
  return temp;
}
void ModelInfo_Model::set_allocated_links(::robotics::gazebotransport::ModelInfo_LINKS* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
bool ModelInfo_Model::has_joints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ModelInfo_Model::set_has_joints() {
  _has_bits_[0] |= 0x00000004u;
}
void ModelInfo_Model::clear_has_joints() {
  _has_bits_[0] &= ~0x00000004u;
}
void ModelInfo_Model::clear_joints() {
  if (joints_ != NULL) joints_->::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
  clear_has_joints();
}
const ::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::robotics::gazebotransport::ModelInfo_JOINTS;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_;
}
::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.joints)
  clear_has_joints();
  ::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = NULL;
  return temp;
}
void ModelInfo_Model::set_allocated_joints(::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
int ModelInfo::model_data_size() const {
  return model_data_.size();
}
void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
const ::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Get(index);
}
::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Add();
}
::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MaxStepSize_TYPE_descriptor_;
}
bool MaxStepSize_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MaxStepSize_TYPE MaxStepSize::SET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize::GET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize::TYPE_MIN;
const MaxStepSize_TYPE MaxStepSize::TYPE_MAX;
const int MaxStepSize::TYPE_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MaxStepSize::kTypeFieldNumber;
const int MaxStepSize::kSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MaxStepSize::MaxStepSize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:robotics.gazebotransport.MaxStepSize)
}

void MaxStepSize::InitAsDefaultInstance() {
}

MaxStepSize::MaxStepSize(const MaxStepSize& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:robotics.gazebotransport.MaxStepSize)
}

void MaxStepSize::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MaxStepSize::~MaxStepSize() {
  // @@protoc_insertion_point(destructor:robotics.gazebotransport.MaxStepSize)
  SharedDtor();
}

void MaxStepSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MaxStepSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MaxStepSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MaxStepSize_descriptor_;
}

const MaxStepSize& MaxStepSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

MaxStepSize* MaxStepSize::default_instance_ = NULL;

MaxStepSize* MaxStepSize::New(::google::protobuf::Arena* arena) const {
  MaxStepSize* n = new MaxStepSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MaxStepSize::Clear() {
// @@protoc_insertion_point(message_clear_start:robotics.gazebotransport.MaxStepSize)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MaxStepSize, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MaxStepSize*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(size_, type_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MaxStepSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:robotics.gazebotransport.MaxStepSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value)) {
            set_type(static_cast< ::robotics::gazebotransport::MaxStepSize_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_size;
        break;
      }

      // required double size = 2;
      case 2: {
        if (tag == 17) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:robotics.gazebotransport.MaxStepSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:robotics.gazebotransport.MaxStepSize)
  return false;
#undef DO_
}

void MaxStepSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:robotics.gazebotransport.MaxStepSize)
  // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required double size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:robotics.gazebotransport.MaxStepSize)
}

::google::protobuf::uint8* MaxStepSize::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:robotics.gazebotransport.MaxStepSize)
  // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required double size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robotics.gazebotransport.MaxStepSize)
  return target;
}

int MaxStepSize::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robotics.gazebotransport.MaxStepSize)
  int total_size = 0;

  if (has_type()) {
    // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_size()) {
    // required double size = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int MaxStepSize::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:robotics.gazebotransport.MaxStepSize)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required double size = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MaxStepSize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robotics.gazebotransport.MaxStepSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MaxStepSize* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MaxStepSize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robotics.gazebotransport.MaxStepSize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robotics.gazebotransport.MaxStepSize)
    MergeFrom(*source);
  }
}

void MaxStepSize::MergeFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robotics.gazebotransport.MaxStepSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MaxStepSize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MaxStepSize::CopyFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxStepSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MaxStepSize::Swap(MaxStepSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MaxStepSize::InternalSwap(MaxStepSize* other) {
  std::swap(type_, other->type_);
  std::swap(size_, other->size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MaxStepSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MaxStepSize_descriptor_;
  metadata.reflection = MaxStepSize_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MaxStepSize

// required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
bool MaxStepSize::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MaxStepSize::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void MaxStepSize::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void MaxStepSize::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.MaxStepSize.type)
  return static_cast< ::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
 void MaxStepSize::set_type(::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
bool MaxStepSize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MaxStepSize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
void MaxStepSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void MaxStepSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
 double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.MaxStepSize.size)
  return size_;
}
 void MaxStepSize::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.MaxStepSize.size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics

// @@protoc_insertion_point(global_scope)
