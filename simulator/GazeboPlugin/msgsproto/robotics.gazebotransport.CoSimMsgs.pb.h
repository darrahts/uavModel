// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robotics.gazebotransport.CoSimMsgs.proto

#ifndef PROTOBUF_robotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED
#define PROTOBUF_robotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace robotics {
namespace gazebotransport {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

class ApplyJointTorque;
class ApplyLinkWrench;
class GetGroundTruthWorldPose;
class GetModelInfo;
class GetPose;
class GetTopicList;
class Image;
class ImuData;
class LaserData;
class MaxStepSize;
class ModelInfo;
class ModelInfo_JOINTS;
class ModelInfo_LINKS;
class ModelInfo_Model;
class Packet;
class PacketHeader;
class Point;
class Pose;
class Quaternion;
class RequestCoSim;
class RequestImage;
class RequestImu;
class RequestLaser;
class ResetSimulation;
class StepSimulation;
class StopCoSim;
class StopSimulation;
class SubscribeImage;
class SubscribeImu;
class SubscribeLaser;
class Time;
class TopicList;
class TopicList_TopicInfo;

enum PacketHeader_MsgID {
  PacketHeader_MsgID_STATUS = 0,
  PacketHeader_MsgID_STEP_SIMULATION = 1,
  PacketHeader_MsgID_RESET_SIMULATION = 2,
  PacketHeader_MsgID_IMAGE = 3,
  PacketHeader_MsgID_REQUEST_IMAGE = 4,
  PacketHeader_MsgID_REQUEST_COSIM = 5,
  PacketHeader_MsgID_STOP_COSIM = 6,
  PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE = 7,
  PacketHeader_MsgID_POSE = 8,
  PacketHeader_MsgID_STOP_SIMULATION = 9,
  PacketHeader_MsgID_LASER_DATA = 10,
  PacketHeader_MsgID_REQUEST_LASER = 11,
  PacketHeader_MsgID_IMU_DATA = 12,
  PacketHeader_MsgID_REQUEST_IMU = 13,
  PacketHeader_MsgID_SUBSCRIBE_IMAGE = 14,
  PacketHeader_MsgID_SUBSCRIBE_LASER = 15,
  PacketHeader_MsgID_SUBSCRIBE_IMU = 16,
  PacketHeader_MsgID_APPLY_JOINT_TORQUE = 17,
  PacketHeader_MsgID_GET_POSE = 18,
  PacketHeader_MsgID_GET_TOPIC_LIST = 19,
  PacketHeader_MsgID_TOPIC_LIST = 20,
  PacketHeader_MsgID_GET_MODEL_INFO = 21,
  PacketHeader_MsgID_MODEL_INFO = 22,
  PacketHeader_MsgID_APPLY_LINK_WRENCH = 23,
  PacketHeader_MsgID_MAX_STEP_SIZE = 24
};
bool PacketHeader_MsgID_IsValid(int value);
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MIN = PacketHeader_MsgID_STATUS;
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MAX = PacketHeader_MsgID_MAX_STEP_SIZE;
const int PacketHeader_MsgID_MsgID_ARRAYSIZE = PacketHeader_MsgID_MsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor();
inline const ::std::string& PacketHeader_MsgID_Name(PacketHeader_MsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketHeader_MsgID_descriptor(), value);
}
inline bool PacketHeader_MsgID_Parse(
    const ::std::string& name, PacketHeader_MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketHeader_MsgID>(
    PacketHeader_MsgID_descriptor(), name, value);
}
enum Packet_CoSimError {
  Packet_CoSimError_NONE = 0,
  Packet_CoSimError_STEP_FAILED = 1,
  Packet_CoSimError_MSG_INVALID = 2,
  Packet_CoSimError_SOCKET_FAILED = 3,
  Packet_CoSimError_RESET_FAILED = 4,
  Packet_CoSimError_COSIM_FAILED = 5,
  Packet_CoSimError_STOP_COSIM_FAILED = 6,
  Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED = 7,
  Packet_CoSimError_RESET_TIME_SCENE_FAILED = 8,
  Packet_CoSimError_RESET_TIME_FAILED = 9,
  Packet_CoSimError_STOP_FAILED = 10,
  Packet_CoSimError_FORCE_TYPE_INVALID = 11,
  Packet_CoSimError_MODEL_NAME_INVALID = 12,
  Packet_CoSimError_LINK_NAME_INVALID = 13,
  Packet_CoSimError_JOINT_NAME_INVALID = 14,
  Packet_CoSimError_TOPIC_NAME_INVALID = 15,
  Packet_CoSimError_TORQUE_TYPE_INVALID = 16,
  Packet_CoSimError_MAX_STEP_SIZE_ERROR = 17
};
bool Packet_CoSimError_IsValid(int value);
const Packet_CoSimError Packet_CoSimError_CoSimError_MIN = Packet_CoSimError_NONE;
const Packet_CoSimError Packet_CoSimError_CoSimError_MAX = Packet_CoSimError_MAX_STEP_SIZE_ERROR;
const int Packet_CoSimError_CoSimError_ARRAYSIZE = Packet_CoSimError_CoSimError_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor();
inline const ::std::string& Packet_CoSimError_Name(Packet_CoSimError value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_CoSimError_descriptor(), value);
}
inline bool Packet_CoSimError_Parse(
    const ::std::string& name, Packet_CoSimError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_CoSimError>(
    Packet_CoSimError_descriptor(), name, value);
}
enum ResetSimulation_ResetBehavior {
  ResetSimulation_ResetBehavior_RESET_TIME = 0,
  ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE = 1
};
bool ResetSimulation_ResetBehavior_IsValid(int value);
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MIN = ResetSimulation_ResetBehavior_RESET_TIME;
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MAX = ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
const int ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE = ResetSimulation_ResetBehavior_ResetBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor();
inline const ::std::string& ResetSimulation_ResetBehavior_Name(ResetSimulation_ResetBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResetSimulation_ResetBehavior_descriptor(), value);
}
inline bool ResetSimulation_ResetBehavior_Parse(
    const ::std::string& name, ResetSimulation_ResetBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResetSimulation_ResetBehavior>(
    ResetSimulation_ResetBehavior_descriptor(), name, value);
}
enum MaxStepSize_TYPE {
  MaxStepSize_TYPE_SET_STEP_SIZE = 0,
  MaxStepSize_TYPE_GET_STEP_SIZE = 1
};
bool MaxStepSize_TYPE_IsValid(int value);
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MIN = MaxStepSize_TYPE_SET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MAX = MaxStepSize_TYPE_GET_STEP_SIZE;
const int MaxStepSize_TYPE_TYPE_ARRAYSIZE = MaxStepSize_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor();
inline const ::std::string& MaxStepSize_TYPE_Name(MaxStepSize_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaxStepSize_TYPE_descriptor(), value);
}
inline bool MaxStepSize_TYPE_Parse(
    const ::std::string& name, MaxStepSize_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaxStepSize_TYPE>(
    MaxStepSize_TYPE_descriptor(), name, value);
}
// ===================================================================

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  inline Time* New() const { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::uint64 seconds() const;
  void set_seconds(::google::protobuf::uint64 value);

  // required uint64 nano_seconds = 2;
  bool has_nano_seconds() const;
  void clear_nano_seconds();
  static const int kNanoSecondsFieldNumber = 2;
  ::google::protobuf::uint64 nano_seconds() const;
  void set_nano_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Time)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_nano_seconds();
  inline void clear_has_nano_seconds();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint64 nano_seconds_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class PacketHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.PacketHeader) */ {
 public:
  PacketHeader();
  virtual ~PacketHeader();

  PacketHeader(const PacketHeader& from);

  inline PacketHeader& operator=(const PacketHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketHeader& default_instance();

  void Swap(PacketHeader* other);

  // implements Message ----------------------------------------------

  inline PacketHeader* New() const { return New(NULL); }

  PacketHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketHeader& from);
  void MergeFrom(const PacketHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PacketHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PacketHeader_MsgID MsgID;
  static const MsgID STATUS =
    PacketHeader_MsgID_STATUS;
  static const MsgID STEP_SIMULATION =
    PacketHeader_MsgID_STEP_SIMULATION;
  static const MsgID RESET_SIMULATION =
    PacketHeader_MsgID_RESET_SIMULATION;
  static const MsgID IMAGE =
    PacketHeader_MsgID_IMAGE;
  static const MsgID REQUEST_IMAGE =
    PacketHeader_MsgID_REQUEST_IMAGE;
  static const MsgID REQUEST_COSIM =
    PacketHeader_MsgID_REQUEST_COSIM;
  static const MsgID STOP_COSIM =
    PacketHeader_MsgID_STOP_COSIM;
  static const MsgID GET_GROUND_TRUTH_WORLD_POSE =
    PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE;
  static const MsgID POSE =
    PacketHeader_MsgID_POSE;
  static const MsgID STOP_SIMULATION =
    PacketHeader_MsgID_STOP_SIMULATION;
  static const MsgID LASER_DATA =
    PacketHeader_MsgID_LASER_DATA;
  static const MsgID REQUEST_LASER =
    PacketHeader_MsgID_REQUEST_LASER;
  static const MsgID IMU_DATA =
    PacketHeader_MsgID_IMU_DATA;
  static const MsgID REQUEST_IMU =
    PacketHeader_MsgID_REQUEST_IMU;
  static const MsgID SUBSCRIBE_IMAGE =
    PacketHeader_MsgID_SUBSCRIBE_IMAGE;
  static const MsgID SUBSCRIBE_LASER =
    PacketHeader_MsgID_SUBSCRIBE_LASER;
  static const MsgID SUBSCRIBE_IMU =
    PacketHeader_MsgID_SUBSCRIBE_IMU;
  static const MsgID APPLY_JOINT_TORQUE =
    PacketHeader_MsgID_APPLY_JOINT_TORQUE;
  static const MsgID GET_POSE =
    PacketHeader_MsgID_GET_POSE;
  static const MsgID GET_TOPIC_LIST =
    PacketHeader_MsgID_GET_TOPIC_LIST;
  static const MsgID TOPIC_LIST =
    PacketHeader_MsgID_TOPIC_LIST;
  static const MsgID GET_MODEL_INFO =
    PacketHeader_MsgID_GET_MODEL_INFO;
  static const MsgID MODEL_INFO =
    PacketHeader_MsgID_MODEL_INFO;
  static const MsgID APPLY_LINK_WRENCH =
    PacketHeader_MsgID_APPLY_LINK_WRENCH;
  static const MsgID MAX_STEP_SIZE =
    PacketHeader_MsgID_MAX_STEP_SIZE;
  static inline bool MsgID_IsValid(int value) {
    return PacketHeader_MsgID_IsValid(value);
  }
  static const MsgID MsgID_MIN =
    PacketHeader_MsgID_MsgID_MIN;
  static const MsgID MsgID_MAX =
    PacketHeader_MsgID_MsgID_MAX;
  static const int MsgID_ARRAYSIZE =
    PacketHeader_MsgID_MsgID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgID_descriptor() {
    return PacketHeader_MsgID_descriptor();
  }
  static inline const ::std::string& MsgID_Name(MsgID value) {
    return PacketHeader_MsgID_Name(value);
  }
  static inline bool MsgID_Parse(const ::std::string& name,
      MsgID* value) {
    return PacketHeader_MsgID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::robotics::gazebotransport::PacketHeader_MsgID id() const;
  void set_id(::robotics::gazebotransport::PacketHeader_MsgID value);

  // required .robotics.gazebotransport.Time time_stamp = 2;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  const ::robotics::gazebotransport::Time& time_stamp() const;
  ::robotics::gazebotransport::Time* mutable_time_stamp();
  ::robotics::gazebotransport::Time* release_time_stamp();
  void set_allocated_time_stamp(::robotics::gazebotransport::Time* time_stamp);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.PacketHeader)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::robotics::gazebotransport::Time* time_stamp_;
  int id_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static PacketHeader* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  enum PayloadCase {
    kStatus = 2,
    kStepSimulation = 3,
    kResetSimulation = 4,
    kImage = 5,
    kRequestImage = 6,
    kRequestCosim = 7,
    kStopCosim = 8,
    kGetGroundTruthWorldPose = 9,
    kPose = 10,
    kStopSimulation = 11,
    kLaserData = 12,
    kRequestLaser = 13,
    kImuData = 14,
    kRequestImu = 15,
    kSubscribeImage = 16,
    kSubscribeLaser = 17,
    kSubscribeImu = 18,
    kApplyJointTorque = 19,
    kGetPose = 20,
    kGetTopicList = 21,
    kTopicList = 22,
    kGetModelInfo = 23,
    kModelInfo = 24,
    kApplyLinkWrench = 25,
    kMaxStepSize = 26,
    PAYLOAD_NOT_SET = 0,
  };

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  inline Packet* New() const { return New(NULL); }

  Packet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_CoSimError CoSimError;
  static const CoSimError NONE =
    Packet_CoSimError_NONE;
  static const CoSimError STEP_FAILED =
    Packet_CoSimError_STEP_FAILED;
  static const CoSimError MSG_INVALID =
    Packet_CoSimError_MSG_INVALID;
  static const CoSimError SOCKET_FAILED =
    Packet_CoSimError_SOCKET_FAILED;
  static const CoSimError RESET_FAILED =
    Packet_CoSimError_RESET_FAILED;
  static const CoSimError COSIM_FAILED =
    Packet_CoSimError_COSIM_FAILED;
  static const CoSimError STOP_COSIM_FAILED =
    Packet_CoSimError_STOP_COSIM_FAILED;
  static const CoSimError GET_GROUND_TRUTH_WORLD_POSE_FAILED =
    Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED;
  static const CoSimError RESET_TIME_SCENE_FAILED =
    Packet_CoSimError_RESET_TIME_SCENE_FAILED;
  static const CoSimError RESET_TIME_FAILED =
    Packet_CoSimError_RESET_TIME_FAILED;
  static const CoSimError STOP_FAILED =
    Packet_CoSimError_STOP_FAILED;
  static const CoSimError FORCE_TYPE_INVALID =
    Packet_CoSimError_FORCE_TYPE_INVALID;
  static const CoSimError MODEL_NAME_INVALID =
    Packet_CoSimError_MODEL_NAME_INVALID;
  static const CoSimError LINK_NAME_INVALID =
    Packet_CoSimError_LINK_NAME_INVALID;
  static const CoSimError JOINT_NAME_INVALID =
    Packet_CoSimError_JOINT_NAME_INVALID;
  static const CoSimError TOPIC_NAME_INVALID =
    Packet_CoSimError_TOPIC_NAME_INVALID;
  static const CoSimError TORQUE_TYPE_INVALID =
    Packet_CoSimError_TORQUE_TYPE_INVALID;
  static const CoSimError MAX_STEP_SIZE_ERROR =
    Packet_CoSimError_MAX_STEP_SIZE_ERROR;
  static inline bool CoSimError_IsValid(int value) {
    return Packet_CoSimError_IsValid(value);
  }
  static const CoSimError CoSimError_MIN =
    Packet_CoSimError_CoSimError_MIN;
  static const CoSimError CoSimError_MAX =
    Packet_CoSimError_CoSimError_MAX;
  static const int CoSimError_ARRAYSIZE =
    Packet_CoSimError_CoSimError_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CoSimError_descriptor() {
    return Packet_CoSimError_descriptor();
  }
  static inline const ::std::string& CoSimError_Name(CoSimError value) {
    return Packet_CoSimError_Name(value);
  }
  static inline bool CoSimError_Parse(const ::std::string& name,
      CoSimError* value) {
    return Packet_CoSimError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.PacketHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::robotics::gazebotransport::PacketHeader& header() const;
  ::robotics::gazebotransport::PacketHeader* mutable_header();
  ::robotics::gazebotransport::PacketHeader* release_header();
  void set_allocated_header(::robotics::gazebotransport::PacketHeader* header);

  // optional .robotics.gazebotransport.Packet.CoSimError status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::robotics::gazebotransport::Packet_CoSimError status() const;
  void set_status(::robotics::gazebotransport::Packet_CoSimError value);

  // optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
  bool has_step_simulation() const;
  void clear_step_simulation();
  static const int kStepSimulationFieldNumber = 3;
  const ::robotics::gazebotransport::StepSimulation& step_simulation() const;
  ::robotics::gazebotransport::StepSimulation* mutable_step_simulation();
  ::robotics::gazebotransport::StepSimulation* release_step_simulation();
  void set_allocated_step_simulation(::robotics::gazebotransport::StepSimulation* step_simulation);

  // optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  bool has_reset_simulation() const;
  void clear_reset_simulation();
  static const int kResetSimulationFieldNumber = 4;
  const ::robotics::gazebotransport::ResetSimulation& reset_simulation() const;
  ::robotics::gazebotransport::ResetSimulation* mutable_reset_simulation();
  ::robotics::gazebotransport::ResetSimulation* release_reset_simulation();
  void set_allocated_reset_simulation(::robotics::gazebotransport::ResetSimulation* reset_simulation);

  // optional .robotics.gazebotransport.Image image = 5;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 5;
  const ::robotics::gazebotransport::Image& image() const;
  ::robotics::gazebotransport::Image* mutable_image();
  ::robotics::gazebotransport::Image* release_image();
  void set_allocated_image(::robotics::gazebotransport::Image* image);

  // optional .robotics.gazebotransport.RequestImage request_image = 6;
  bool has_request_image() const;
  void clear_request_image();
  static const int kRequestImageFieldNumber = 6;
  const ::robotics::gazebotransport::RequestImage& request_image() const;
  ::robotics::gazebotransport::RequestImage* mutable_request_image();
  ::robotics::gazebotransport::RequestImage* release_request_image();
  void set_allocated_request_image(::robotics::gazebotransport::RequestImage* request_image);

  // optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
  bool has_request_cosim() const;
  void clear_request_cosim();
  static const int kRequestCosimFieldNumber = 7;
  const ::robotics::gazebotransport::RequestCoSim& request_cosim() const;
  ::robotics::gazebotransport::RequestCoSim* mutable_request_cosim();
  ::robotics::gazebotransport::RequestCoSim* release_request_cosim();
  void set_allocated_request_cosim(::robotics::gazebotransport::RequestCoSim* request_cosim);

  // optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
  bool has_stop_cosim() const;
  void clear_stop_cosim();
  static const int kStopCosimFieldNumber = 8;
  const ::robotics::gazebotransport::StopCoSim& stop_cosim() const;
  ::robotics::gazebotransport::StopCoSim* mutable_stop_cosim();
  ::robotics::gazebotransport::StopCoSim* release_stop_cosim();
  void set_allocated_stop_cosim(::robotics::gazebotransport::StopCoSim* stop_cosim);

  // optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  bool has_get_ground_truth_world_pose() const;
  void clear_get_ground_truth_world_pose();
  static const int kGetGroundTruthWorldPoseFieldNumber = 9;
  const ::robotics::gazebotransport::GetGroundTruthWorldPose& get_ground_truth_world_pose() const;
  ::robotics::gazebotransport::GetGroundTruthWorldPose* mutable_get_ground_truth_world_pose();
  ::robotics::gazebotransport::GetGroundTruthWorldPose* release_get_ground_truth_world_pose();
  void set_allocated_get_ground_truth_world_pose(::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose);

  // optional .robotics.gazebotransport.Pose pose = 10;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 10;
  const ::robotics::gazebotransport::Pose& pose() const;
  ::robotics::gazebotransport::Pose* mutable_pose();
  ::robotics::gazebotransport::Pose* release_pose();
  void set_allocated_pose(::robotics::gazebotransport::Pose* pose);

  // optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
  bool has_stop_simulation() const;
  void clear_stop_simulation();
  static const int kStopSimulationFieldNumber = 11;
  const ::robotics::gazebotransport::StopSimulation& stop_simulation() const;
  ::robotics::gazebotransport::StopSimulation* mutable_stop_simulation();
  ::robotics::gazebotransport::StopSimulation* release_stop_simulation();
  void set_allocated_stop_simulation(::robotics::gazebotransport::StopSimulation* stop_simulation);

  // optional .robotics.gazebotransport.LaserData laser_data = 12;
  bool has_laser_data() const;
  void clear_laser_data();
  static const int kLaserDataFieldNumber = 12;
  const ::robotics::gazebotransport::LaserData& laser_data() const;
  ::robotics::gazebotransport::LaserData* mutable_laser_data();
  ::robotics::gazebotransport::LaserData* release_laser_data();
  void set_allocated_laser_data(::robotics::gazebotransport::LaserData* laser_data);

  // optional .robotics.gazebotransport.RequestLaser request_laser = 13;
  bool has_request_laser() const;
  void clear_request_laser();
  static const int kRequestLaserFieldNumber = 13;
  const ::robotics::gazebotransport::RequestLaser& request_laser() const;
  ::robotics::gazebotransport::RequestLaser* mutable_request_laser();
  ::robotics::gazebotransport::RequestLaser* release_request_laser();
  void set_allocated_request_laser(::robotics::gazebotransport::RequestLaser* request_laser);

  // optional .robotics.gazebotransport.ImuData imu_data = 14;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 14;
  const ::robotics::gazebotransport::ImuData& imu_data() const;
  ::robotics::gazebotransport::ImuData* mutable_imu_data();
  ::robotics::gazebotransport::ImuData* release_imu_data();
  void set_allocated_imu_data(::robotics::gazebotransport::ImuData* imu_data);

  // optional .robotics.gazebotransport.RequestImu request_imu = 15;
  bool has_request_imu() const;
  void clear_request_imu();
  static const int kRequestImuFieldNumber = 15;
  const ::robotics::gazebotransport::RequestImu& request_imu() const;
  ::robotics::gazebotransport::RequestImu* mutable_request_imu();
  ::robotics::gazebotransport::RequestImu* release_request_imu();
  void set_allocated_request_imu(::robotics::gazebotransport::RequestImu* request_imu);

  // optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  bool has_subscribe_image() const;
  void clear_subscribe_image();
  static const int kSubscribeImageFieldNumber = 16;
  const ::robotics::gazebotransport::SubscribeImage& subscribe_image() const;
  ::robotics::gazebotransport::SubscribeImage* mutable_subscribe_image();
  ::robotics::gazebotransport::SubscribeImage* release_subscribe_image();
  void set_allocated_subscribe_image(::robotics::gazebotransport::SubscribeImage* subscribe_image);

  // optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  bool has_subscribe_laser() const;
  void clear_subscribe_laser();
  static const int kSubscribeLaserFieldNumber = 17;
  const ::robotics::gazebotransport::SubscribeLaser& subscribe_laser() const;
  ::robotics::gazebotransport::SubscribeLaser* mutable_subscribe_laser();
  ::robotics::gazebotransport::SubscribeLaser* release_subscribe_laser();
  void set_allocated_subscribe_laser(::robotics::gazebotransport::SubscribeLaser* subscribe_laser);

  // optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  bool has_subscribe_imu() const;
  void clear_subscribe_imu();
  static const int kSubscribeImuFieldNumber = 18;
  const ::robotics::gazebotransport::SubscribeImu& subscribe_imu() const;
  ::robotics::gazebotransport::SubscribeImu* mutable_subscribe_imu();
  ::robotics::gazebotransport::SubscribeImu* release_subscribe_imu();
  void set_allocated_subscribe_imu(::robotics::gazebotransport::SubscribeImu* subscribe_imu);

  // optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  bool has_apply_joint_torque() const;
  void clear_apply_joint_torque();
  static const int kApplyJointTorqueFieldNumber = 19;
  const ::robotics::gazebotransport::ApplyJointTorque& apply_joint_torque() const;
  ::robotics::gazebotransport::ApplyJointTorque* mutable_apply_joint_torque();
  ::robotics::gazebotransport::ApplyJointTorque* release_apply_joint_torque();
  void set_allocated_apply_joint_torque(::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque);

  // optional .robotics.gazebotransport.GetPose get_pose = 20;
  bool has_get_pose() const;
  void clear_get_pose();
  static const int kGetPoseFieldNumber = 20;
  const ::robotics::gazebotransport::GetPose& get_pose() const;
  ::robotics::gazebotransport::GetPose* mutable_get_pose();
  ::robotics::gazebotransport::GetPose* release_get_pose();
  void set_allocated_get_pose(::robotics::gazebotransport::GetPose* get_pose);

  // optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
  bool has_get_topic_list() const;
  void clear_get_topic_list();
  static const int kGetTopicListFieldNumber = 21;
  const ::robotics::gazebotransport::GetTopicList& get_topic_list() const;
  ::robotics::gazebotransport::GetTopicList* mutable_get_topic_list();
  ::robotics::gazebotransport::GetTopicList* release_get_topic_list();
  void set_allocated_get_topic_list(::robotics::gazebotransport::GetTopicList* get_topic_list);

  // optional .robotics.gazebotransport.TopicList topic_list = 22;
  bool has_topic_list() const;
  void clear_topic_list();
  static const int kTopicListFieldNumber = 22;
  const ::robotics::gazebotransport::TopicList& topic_list() const;
  ::robotics::gazebotransport::TopicList* mutable_topic_list();
  ::robotics::gazebotransport::TopicList* release_topic_list();
  void set_allocated_topic_list(::robotics::gazebotransport::TopicList* topic_list);

  // optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
  bool has_get_model_info() const;
  void clear_get_model_info();
  static const int kGetModelInfoFieldNumber = 23;
  const ::robotics::gazebotransport::GetModelInfo& get_model_info() const;
  ::robotics::gazebotransport::GetModelInfo* mutable_get_model_info();
  ::robotics::gazebotransport::GetModelInfo* release_get_model_info();
  void set_allocated_get_model_info(::robotics::gazebotransport::GetModelInfo* get_model_info);

  // optional .robotics.gazebotransport.ModelInfo model_info = 24;
  bool has_model_info() const;
  void clear_model_info();
  static const int kModelInfoFieldNumber = 24;
  const ::robotics::gazebotransport::ModelInfo& model_info() const;
  ::robotics::gazebotransport::ModelInfo* mutable_model_info();
  ::robotics::gazebotransport::ModelInfo* release_model_info();
  void set_allocated_model_info(::robotics::gazebotransport::ModelInfo* model_info);

  // optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  bool has_apply_link_wrench() const;
  void clear_apply_link_wrench();
  static const int kApplyLinkWrenchFieldNumber = 25;
  const ::robotics::gazebotransport::ApplyLinkWrench& apply_link_wrench() const;
  ::robotics::gazebotransport::ApplyLinkWrench* mutable_apply_link_wrench();
  ::robotics::gazebotransport::ApplyLinkWrench* release_apply_link_wrench();
  void set_allocated_apply_link_wrench(::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench);

  // optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
  bool has_max_step_size() const;
  void clear_max_step_size();
  static const int kMaxStepSizeFieldNumber = 26;
  const ::robotics::gazebotransport::MaxStepSize& max_step_size() const;
  ::robotics::gazebotransport::MaxStepSize* mutable_max_step_size();
  ::robotics::gazebotransport::MaxStepSize* release_max_step_size();
  void set_allocated_max_step_size(::robotics::gazebotransport::MaxStepSize* max_step_size);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Packet)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_status();
  inline void set_has_step_simulation();
  inline void set_has_reset_simulation();
  inline void set_has_image();
  inline void set_has_request_image();
  inline void set_has_request_cosim();
  inline void set_has_stop_cosim();
  inline void set_has_get_ground_truth_world_pose();
  inline void set_has_pose();
  inline void set_has_stop_simulation();
  inline void set_has_laser_data();
  inline void set_has_request_laser();
  inline void set_has_imu_data();
  inline void set_has_request_imu();
  inline void set_has_subscribe_image();
  inline void set_has_subscribe_laser();
  inline void set_has_subscribe_imu();
  inline void set_has_apply_joint_torque();
  inline void set_has_get_pose();
  inline void set_has_get_topic_list();
  inline void set_has_topic_list();
  inline void set_has_get_model_info();
  inline void set_has_model_info();
  inline void set_has_apply_link_wrench();
  inline void set_has_max_step_size();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::robotics::gazebotransport::PacketHeader* header_;
  union PayloadUnion {
    PayloadUnion() {}
    int status_;
    ::robotics::gazebotransport::StepSimulation* step_simulation_;
    ::robotics::gazebotransport::ResetSimulation* reset_simulation_;
    ::robotics::gazebotransport::Image* image_;
    ::robotics::gazebotransport::RequestImage* request_image_;
    ::robotics::gazebotransport::RequestCoSim* request_cosim_;
    ::robotics::gazebotransport::StopCoSim* stop_cosim_;
    ::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
    ::robotics::gazebotransport::Pose* pose_;
    ::robotics::gazebotransport::StopSimulation* stop_simulation_;
    ::robotics::gazebotransport::LaserData* laser_data_;
    ::robotics::gazebotransport::RequestLaser* request_laser_;
    ::robotics::gazebotransport::ImuData* imu_data_;
    ::robotics::gazebotransport::RequestImu* request_imu_;
    ::robotics::gazebotransport::SubscribeImage* subscribe_image_;
    ::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
    ::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
    ::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
    ::robotics::gazebotransport::GetPose* get_pose_;
    ::robotics::gazebotransport::GetTopicList* get_topic_list_;
    ::robotics::gazebotransport::TopicList* topic_list_;
    ::robotics::gazebotransport::GetModelInfo* get_model_info_;
    ::robotics::gazebotransport::ModelInfo* model_info_;
    ::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
    ::robotics::gazebotransport::MaxStepSize* max_step_size_;
  } payload_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// -------------------------------------------------------------------

class StepSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.StepSimulation) */ {
 public:
  StepSimulation();
  virtual ~StepSimulation();

  StepSimulation(const StepSimulation& from);

  inline StepSimulation& operator=(const StepSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepSimulation& default_instance();

  void Swap(StepSimulation* other);

  // implements Message ----------------------------------------------

  inline StepSimulation* New() const { return New(NULL); }

  StepSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepSimulation& from);
  void MergeFrom(const StepSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StepSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_steps = 1;
  bool has_num_steps() const;
  void clear_num_steps();
  static const int kNumStepsFieldNumber = 1;
  ::google::protobuf::uint32 num_steps() const;
  void set_num_steps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.StepSimulation)
 private:
  inline void set_has_num_steps();
  inline void clear_has_num_steps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_steps_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StepSimulation* default_instance_;
};
// -------------------------------------------------------------------

class ResetSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ResetSimulation) */ {
 public:
  ResetSimulation();
  virtual ~ResetSimulation();

  ResetSimulation(const ResetSimulation& from);

  inline ResetSimulation& operator=(const ResetSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetSimulation& default_instance();

  void Swap(ResetSimulation* other);

  // implements Message ----------------------------------------------

  inline ResetSimulation* New() const { return New(NULL); }

  ResetSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetSimulation& from);
  void MergeFrom(const ResetSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResetSimulation_ResetBehavior ResetBehavior;
  static const ResetBehavior RESET_TIME =
    ResetSimulation_ResetBehavior_RESET_TIME;
  static const ResetBehavior RESET_TIME_AND_SCENE =
    ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
  static inline bool ResetBehavior_IsValid(int value) {
    return ResetSimulation_ResetBehavior_IsValid(value);
  }
  static const ResetBehavior ResetBehavior_MIN =
    ResetSimulation_ResetBehavior_ResetBehavior_MIN;
  static const ResetBehavior ResetBehavior_MAX =
    ResetSimulation_ResetBehavior_ResetBehavior_MAX;
  static const int ResetBehavior_ARRAYSIZE =
    ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResetBehavior_descriptor() {
    return ResetSimulation_ResetBehavior_descriptor();
  }
  static inline const ::std::string& ResetBehavior_Name(ResetBehavior value) {
    return ResetSimulation_ResetBehavior_Name(value);
  }
  static inline bool ResetBehavior_Parse(const ::std::string& name,
      ResetBehavior* value) {
    return ResetSimulation_ResetBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  bool has_behavior() const;
  void clear_behavior();
  static const int kBehaviorFieldNumber = 1;
  ::robotics::gazebotransport::ResetSimulation_ResetBehavior behavior() const;
  void set_behavior(::robotics::gazebotransport::ResetSimulation_ResetBehavior value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ResetSimulation)
 private:
  inline void set_has_behavior();
  inline void clear_has_behavior();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int behavior_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ResetSimulation* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  inline Image* New() const { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required string data_type = 4;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Image)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data_type();
  inline void clear_has_data_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class RequestImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.RequestImage) */ {
 public:
  RequestImage();
  virtual ~RequestImage();

  RequestImage(const RequestImage& from);

  inline RequestImage& operator=(const RequestImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImage& default_instance();

  void Swap(RequestImage* other);

  // implements Message ----------------------------------------------

  inline RequestImage* New() const { return New(NULL); }

  RequestImage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestImage& from);
  void MergeFrom(const RequestImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.RequestImage)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestImage* default_instance_;
};
// -------------------------------------------------------------------

class RequestCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.RequestCoSim) */ {
 public:
  RequestCoSim();
  virtual ~RequestCoSim();

  RequestCoSim(const RequestCoSim& from);

  inline RequestCoSim& operator=(const RequestCoSim& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCoSim& default_instance();

  void Swap(RequestCoSim* other);

  // implements Message ----------------------------------------------

  inline RequestCoSim* New() const { return New(NULL); }

  RequestCoSim* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCoSim& from);
  void MergeFrom(const RequestCoSim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // required double duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  double duration() const;
  void set_duration(double value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.RequestCoSim)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  double duration_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestCoSim* default_instance_;
};
// -------------------------------------------------------------------

class StopCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.StopCoSim) */ {
 public:
  StopCoSim();
  virtual ~StopCoSim();

  StopCoSim(const StopCoSim& from);

  inline StopCoSim& operator=(const StopCoSim& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopCoSim& default_instance();

  void Swap(StopCoSim* other);

  // implements Message ----------------------------------------------

  inline StopCoSim* New() const { return New(NULL); }

  StopCoSim* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopCoSim& from);
  void MergeFrom(const StopCoSim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.StopCoSim)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StopCoSim* default_instance_;
};
// -------------------------------------------------------------------

class GetGroundTruthWorldPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.GetGroundTruthWorldPose) */ {
 public:
  GetGroundTruthWorldPose();
  virtual ~GetGroundTruthWorldPose();

  GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from);

  inline GetGroundTruthWorldPose& operator=(const GetGroundTruthWorldPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGroundTruthWorldPose& default_instance();

  void Swap(GetGroundTruthWorldPose* other);

  // implements Message ----------------------------------------------

  inline GetGroundTruthWorldPose* New() const { return New(NULL); }

  GetGroundTruthWorldPose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGroundTruthWorldPose& from);
  void MergeFrom(const GetGroundTruthWorldPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetGroundTruthWorldPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.GetGroundTruthWorldPose)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetGroundTruthWorldPose* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  inline Quaternion* New() const { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Quaternion)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::robotics::gazebotransport::Point& position() const;
  ::robotics::gazebotransport::Point* mutable_position();
  ::robotics::gazebotransport::Point* release_position();
  void set_allocated_position(::robotics::gazebotransport::Point* position);

  // required .robotics.gazebotransport.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::robotics::gazebotransport::Quaternion& orientation() const;
  ::robotics::gazebotransport::Quaternion* mutable_orientation();
  ::robotics::gazebotransport::Quaternion* release_orientation();
  void set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::robotics::gazebotransport::Point* position_;
  ::robotics::gazebotransport::Quaternion* orientation_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class StopSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.StopSimulation) */ {
 public:
  StopSimulation();
  virtual ~StopSimulation();

  StopSimulation(const StopSimulation& from);

  inline StopSimulation& operator=(const StopSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSimulation& default_instance();

  void Swap(StopSimulation* other);

  // implements Message ----------------------------------------------

  inline StopSimulation* New() const { return New(NULL); }

  StopSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSimulation& from);
  void MergeFrom(const StopSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool stop_scene = 1;
  bool has_stop_scene() const;
  void clear_stop_scene();
  static const int kStopSceneFieldNumber = 1;
  bool stop_scene() const;
  void set_stop_scene(bool value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.StopSimulation)
 private:
  inline void set_has_stop_scene();
  inline void clear_has_stop_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool stop_scene_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StopSimulation* default_instance_;
};
// -------------------------------------------------------------------

class LaserData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.LaserData) */ {
 public:
  LaserData();
  virtual ~LaserData();

  LaserData(const LaserData& from);

  inline LaserData& operator=(const LaserData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserData& default_instance();

  void Swap(LaserData* other);

  // implements Message ----------------------------------------------

  inline LaserData* New() const { return New(NULL); }

  LaserData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserData& from);
  void MergeFrom(const LaserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaserData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double angle_min = 1;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  double angle_min() const;
  void set_angle_min(double value);

  // required double angle_max = 2;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  double angle_max() const;
  void set_angle_max(double value);

  // required double angle_step = 3;
  bool has_angle_step() const;
  void clear_angle_step();
  static const int kAngleStepFieldNumber = 3;
  double angle_step() const;
  void set_angle_step(double value);

  // required double range_min = 4;
  bool has_range_min() const;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 4;
  double range_min() const;
  void set_range_min(double value);

  // required double range_max = 5;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  double range_max() const;
  void set_range_max(double value);

  // required double count = 6;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 6;
  double count() const;
  void set_count(double value);

  // required double vertical_angle_min = 7;
  bool has_vertical_angle_min() const;
  void clear_vertical_angle_min();
  static const int kVerticalAngleMinFieldNumber = 7;
  double vertical_angle_min() const;
  void set_vertical_angle_min(double value);

  // required double vertical_angle_max = 8;
  bool has_vertical_angle_max() const;
  void clear_vertical_angle_max();
  static const int kVerticalAngleMaxFieldNumber = 8;
  double vertical_angle_max() const;
  void set_vertical_angle_max(double value);

  // required double vertical_angle_step = 9;
  bool has_vertical_angle_step() const;
  void clear_vertical_angle_step();
  static const int kVerticalAngleStepFieldNumber = 9;
  double vertical_angle_step() const;
  void set_vertical_angle_step(double value);

  // repeated double range = 10;
  int range_size() const;
  void clear_range();
  static const int kRangeFieldNumber = 10;
  double range(int index) const;
  void set_range(int index, double value);
  void add_range(double value);
  const ::google::protobuf::RepeatedField< double >&
      range() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_range();

  // repeated double intensities = 11;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 11;
  double intensities(int index) const;
  void set_intensities(int index, double value);
  void add_intensities(double value);
  const ::google::protobuf::RepeatedField< double >&
      intensities() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_intensities();

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.LaserData)
 private:
  inline void set_has_angle_min();
  inline void clear_has_angle_min();
  inline void set_has_angle_max();
  inline void clear_has_angle_max();
  inline void set_has_angle_step();
  inline void clear_has_angle_step();
  inline void set_has_range_min();
  inline void clear_has_range_min();
  inline void set_has_range_max();
  inline void clear_has_range_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_vertical_angle_min();
  inline void clear_has_vertical_angle_min();
  inline void set_has_vertical_angle_max();
  inline void clear_has_vertical_angle_max();
  inline void set_has_vertical_angle_step();
  inline void clear_has_vertical_angle_step();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double angle_min_;
  double angle_max_;
  double angle_step_;
  double range_min_;
  double range_max_;
  double count_;
  double vertical_angle_min_;
  double vertical_angle_max_;
  double vertical_angle_step_;
  ::google::protobuf::RepeatedField< double > range_;
  ::google::protobuf::RepeatedField< double > intensities_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static LaserData* default_instance_;
};
// -------------------------------------------------------------------

class RequestLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.RequestLaser) */ {
 public:
  RequestLaser();
  virtual ~RequestLaser();

  RequestLaser(const RequestLaser& from);

  inline RequestLaser& operator=(const RequestLaser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLaser& default_instance();

  void Swap(RequestLaser* other);

  // implements Message ----------------------------------------------

  inline RequestLaser* New() const { return New(NULL); }

  RequestLaser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLaser& from);
  void MergeFrom(const RequestLaser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.RequestLaser)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestLaser* default_instance_;
};
// -------------------------------------------------------------------

class ImuData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ImuData) */ {
 public:
  ImuData();
  virtual ~ImuData();

  ImuData(const ImuData& from);

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImuData& default_instance();

  void Swap(ImuData* other);

  // implements Message ----------------------------------------------

  inline ImuData* New() const { return New(NULL); }

  ImuData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImuData& from);
  void MergeFrom(const ImuData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImuData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.Point linear_acceleration = 1;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 1;
  const ::robotics::gazebotransport::Point& linear_acceleration() const;
  ::robotics::gazebotransport::Point* mutable_linear_acceleration();
  ::robotics::gazebotransport::Point* release_linear_acceleration();
  void set_allocated_linear_acceleration(::robotics::gazebotransport::Point* linear_acceleration);

  // required .robotics.gazebotransport.Point angular_velocity = 2;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 2;
  const ::robotics::gazebotransport::Point& angular_velocity() const;
  ::robotics::gazebotransport::Point* mutable_angular_velocity();
  ::robotics::gazebotransport::Point* release_angular_velocity();
  void set_allocated_angular_velocity(::robotics::gazebotransport::Point* angular_velocity);

  // required .robotics.gazebotransport.Quaternion orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::robotics::gazebotransport::Quaternion& orientation() const;
  ::robotics::gazebotransport::Quaternion* mutable_orientation();
  ::robotics::gazebotransport::Quaternion* release_orientation();
  void set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ImuData)
 private:
  inline void set_has_linear_acceleration();
  inline void clear_has_linear_acceleration();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::robotics::gazebotransport::Point* linear_acceleration_;
  ::robotics::gazebotransport::Point* angular_velocity_;
  ::robotics::gazebotransport::Quaternion* orientation_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ImuData* default_instance_;
};
// -------------------------------------------------------------------

class RequestImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.RequestImu) */ {
 public:
  RequestImu();
  virtual ~RequestImu();

  RequestImu(const RequestImu& from);

  inline RequestImu& operator=(const RequestImu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImu& default_instance();

  void Swap(RequestImu* other);

  // implements Message ----------------------------------------------

  inline RequestImu* New() const { return New(NULL); }

  RequestImu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestImu& from);
  void MergeFrom(const RequestImu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.RequestImu)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestImu* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.SubscribeImage) */ {
 public:
  SubscribeImage();
  virtual ~SubscribeImage();

  SubscribeImage(const SubscribeImage& from);

  inline SubscribeImage& operator=(const SubscribeImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImage& default_instance();

  void Swap(SubscribeImage* other);

  // implements Message ----------------------------------------------

  inline SubscribeImage* New() const { return New(NULL); }

  SubscribeImage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImage& from);
  void MergeFrom(const SubscribeImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.SubscribeImage)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeImage* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.SubscribeLaser) */ {
 public:
  SubscribeLaser();
  virtual ~SubscribeLaser();

  SubscribeLaser(const SubscribeLaser& from);

  inline SubscribeLaser& operator=(const SubscribeLaser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeLaser& default_instance();

  void Swap(SubscribeLaser* other);

  // implements Message ----------------------------------------------

  inline SubscribeLaser* New() const { return New(NULL); }

  SubscribeLaser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeLaser& from);
  void MergeFrom(const SubscribeLaser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.SubscribeLaser)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeLaser* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.SubscribeImu) */ {
 public:
  SubscribeImu();
  virtual ~SubscribeImu();

  SubscribeImu(const SubscribeImu& from);

  inline SubscribeImu& operator=(const SubscribeImu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImu& default_instance();

  void Swap(SubscribeImu* other);

  // implements Message ----------------------------------------------

  inline SubscribeImu* New() const { return New(NULL); }

  SubscribeImu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImu& from);
  void MergeFrom(const SubscribeImu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.SubscribeImu)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeImu* default_instance_;
};
// -------------------------------------------------------------------

class ApplyLinkWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ApplyLinkWrench) */ {
 public:
  ApplyLinkWrench();
  virtual ~ApplyLinkWrench();

  ApplyLinkWrench(const ApplyLinkWrench& from);

  inline ApplyLinkWrench& operator=(const ApplyLinkWrench& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyLinkWrench& default_instance();

  void Swap(ApplyLinkWrench* other);

  // implements Message ----------------------------------------------

  inline ApplyLinkWrench* New() const { return New(NULL); }

  ApplyLinkWrench* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyLinkWrench& from);
  void MergeFrom(const ApplyLinkWrench& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApplyLinkWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required string force_type = 3;
  bool has_force_type() const;
  void clear_force_type();
  static const int kForceTypeFieldNumber = 3;
  const ::std::string& force_type() const;
  void set_force_type(const ::std::string& value);
  void set_force_type(const char* value);
  void set_force_type(const char* value, size_t size);
  ::std::string* mutable_force_type();
  ::std::string* release_force_type();
  void set_allocated_force_type(::std::string* force_type);

  // required double fx = 4;
  bool has_fx() const;
  void clear_fx();
  static const int kFxFieldNumber = 4;
  double fx() const;
  void set_fx(double value);

  // required double fy = 5;
  bool has_fy() const;
  void clear_fy();
  static const int kFyFieldNumber = 5;
  double fy() const;
  void set_fy(double value);

  // required double fz = 6;
  bool has_fz() const;
  void clear_fz();
  static const int kFzFieldNumber = 6;
  double fz() const;
  void set_fz(double value);

  // required string torque_type = 7;
  bool has_torque_type() const;
  void clear_torque_type();
  static const int kTorqueTypeFieldNumber = 7;
  const ::std::string& torque_type() const;
  void set_torque_type(const ::std::string& value);
  void set_torque_type(const char* value);
  void set_torque_type(const char* value, size_t size);
  ::std::string* mutable_torque_type();
  ::std::string* release_torque_type();
  void set_allocated_torque_type(::std::string* torque_type);

  // required double tx = 8;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 8;
  double tx() const;
  void set_tx(double value);

  // required double ty = 9;
  bool has_ty() const;
  void clear_ty();
  static const int kTyFieldNumber = 9;
  double ty() const;
  void set_ty(double value);

  // required double tz = 10;
  bool has_tz() const;
  void clear_tz();
  static const int kTzFieldNumber = 10;
  double tz() const;
  void set_tz(double value);

  // required .robotics.gazebotransport.Time duration = 11;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 11;
  const ::robotics::gazebotransport::Time& duration() const;
  ::robotics::gazebotransport::Time* mutable_duration();
  ::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ApplyLinkWrench)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_force_type();
  inline void clear_has_force_type();
  inline void set_has_fx();
  inline void clear_has_fx();
  inline void set_has_fy();
  inline void clear_has_fy();
  inline void set_has_fz();
  inline void clear_has_fz();
  inline void set_has_torque_type();
  inline void clear_has_torque_type();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_tz();
  inline void clear_has_tz();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::google::protobuf::internal::ArenaStringPtr force_type_;
  double fx_;
  double fy_;
  double fz_;
  ::google::protobuf::internal::ArenaStringPtr torque_type_;
  double tx_;
  double ty_;
  double tz_;
  ::robotics::gazebotransport::Time* duration_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ApplyLinkWrench* default_instance_;
};
// -------------------------------------------------------------------

class ApplyJointTorque : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ApplyJointTorque) */ {
 public:
  ApplyJointTorque();
  virtual ~ApplyJointTorque();

  ApplyJointTorque(const ApplyJointTorque& from);

  inline ApplyJointTorque& operator=(const ApplyJointTorque& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyJointTorque& default_instance();

  void Swap(ApplyJointTorque* other);

  // implements Message ----------------------------------------------

  inline ApplyJointTorque* New() const { return New(NULL); }

  ApplyJointTorque* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyJointTorque& from);
  void MergeFrom(const ApplyJointTorque& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApplyJointTorque* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required double effort = 4;
  bool has_effort() const;
  void clear_effort();
  static const int kEffortFieldNumber = 4;
  double effort() const;
  void set_effort(double value);

  // required .robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  const ::robotics::gazebotransport::Time& duration() const;
  ::robotics::gazebotransport::Time* mutable_duration();
  ::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ApplyJointTorque)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_effort();
  inline void clear_has_effort();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  double effort_;
  ::robotics::gazebotransport::Time* duration_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ApplyJointTorque* default_instance_;
};
// -------------------------------------------------------------------

class GetPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.GetPose) */ {
 public:
  GetPose();
  virtual ~GetPose();

  GetPose(const GetPose& from);

  inline GetPose& operator=(const GetPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPose& default_instance();

  void Swap(GetPose* other);

  // implements Message ----------------------------------------------

  inline GetPose* New() const { return New(NULL); }

  GetPose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPose& from);
  void MergeFrom(const GetPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.GetPose)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetPose* default_instance_;
};
// -------------------------------------------------------------------

class GetTopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.GetTopicList) */ {
 public:
  GetTopicList();
  virtual ~GetTopicList();

  GetTopicList(const GetTopicList& from);

  inline GetTopicList& operator=(const GetTopicList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTopicList& default_instance();

  void Swap(GetTopicList* other);

  // implements Message ----------------------------------------------

  inline GetTopicList* New() const { return New(NULL); }

  GetTopicList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTopicList& from);
  void MergeFrom(const GetTopicList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.GetTopicList)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetTopicList* default_instance_;
};
// -------------------------------------------------------------------

class TopicList_TopicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.TopicList.TopicInfo) */ {
 public:
  TopicList_TopicInfo();
  virtual ~TopicList_TopicInfo();

  TopicList_TopicInfo(const TopicList_TopicInfo& from);

  inline TopicList_TopicInfo& operator=(const TopicList_TopicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList_TopicInfo& default_instance();

  void Swap(TopicList_TopicInfo* other);

  // implements Message ----------------------------------------------

  inline TopicList_TopicInfo* New() const { return New(NULL); }

  TopicList_TopicInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicList_TopicInfo& from);
  void MergeFrom(const TopicList_TopicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicList_TopicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.TopicList.TopicInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static TopicList_TopicInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.TopicList) */ {
 public:
  TopicList();
  virtual ~TopicList();

  TopicList(const TopicList& from);

  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList& default_instance();

  void Swap(TopicList* other);

  // implements Message ----------------------------------------------

  inline TopicList* New() const { return New(NULL); }

  TopicList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicList& from);
  void MergeFrom(const TopicList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TopicList_TopicInfo TopicInfo;

  // accessors -------------------------------------------------------

  // repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::robotics::gazebotransport::TopicList_TopicInfo& data(int index) const;
  ::robotics::gazebotransport::TopicList_TopicInfo* mutable_data(int index);
  ::robotics::gazebotransport::TopicList_TopicInfo* add_data();
  ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >&
      data() const;

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.TopicList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo > data_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static TopicList* default_instance_;
};
// -------------------------------------------------------------------

class GetModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.GetModelInfo) */ {
 public:
  GetModelInfo();
  virtual ~GetModelInfo();

  GetModelInfo(const GetModelInfo& from);

  inline GetModelInfo& operator=(const GetModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetModelInfo& default_instance();

  void Swap(GetModelInfo* other);

  // implements Message ----------------------------------------------

  inline GetModelInfo* New() const { return New(NULL); }

  GetModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetModelInfo& from);
  void MergeFrom(const GetModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.GetModelInfo)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_LINKS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ModelInfo.LINKS) */ {
 public:
  ModelInfo_LINKS();
  virtual ~ModelInfo_LINKS();

  ModelInfo_LINKS(const ModelInfo_LINKS& from);

  inline ModelInfo_LINKS& operator=(const ModelInfo_LINKS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_LINKS& default_instance();

  void Swap(ModelInfo_LINKS* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_LINKS* New() const { return New(NULL); }

  ModelInfo_LINKS* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_LINKS& from);
  void MergeFrom(const ModelInfo_LINKS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_LINKS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string link_name = 1;
  int link_name_size() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 1;
  const ::std::string& link_name(int index) const;
  ::std::string* mutable_link_name(int index);
  void set_link_name(int index, const ::std::string& value);
  void set_link_name(int index, const char* value);
  void set_link_name(int index, const char* value, size_t size);
  ::std::string* add_link_name();
  void add_link_name(const ::std::string& value);
  void add_link_name(const char* value);
  void add_link_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_name();

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ModelInfo.LINKS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_LINKS* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_JOINTS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ModelInfo.JOINTS) */ {
 public:
  ModelInfo_JOINTS();
  virtual ~ModelInfo_JOINTS();

  ModelInfo_JOINTS(const ModelInfo_JOINTS& from);

  inline ModelInfo_JOINTS& operator=(const ModelInfo_JOINTS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_JOINTS& default_instance();

  void Swap(ModelInfo_JOINTS* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_JOINTS* New() const { return New(NULL); }

  ModelInfo_JOINTS* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_JOINTS& from);
  void MergeFrom(const ModelInfo_JOINTS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_JOINTS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string joint_name = 1;
  int joint_name_size() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 1;
  const ::std::string& joint_name(int index) const;
  ::std::string* mutable_joint_name(int index);
  void set_joint_name(int index, const ::std::string& value);
  void set_joint_name(int index, const char* value);
  void set_joint_name(int index, const char* value, size_t size);
  ::std::string* add_joint_name();
  void add_joint_name(const ::std::string& value);
  void add_joint_name(const char* value);
  void add_joint_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& joint_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_joint_name();

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ModelInfo.JOINTS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> joint_name_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_JOINTS* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ModelInfo.Model) */ {
 public:
  ModelInfo_Model();
  virtual ~ModelInfo_Model();

  ModelInfo_Model(const ModelInfo_Model& from);

  inline ModelInfo_Model& operator=(const ModelInfo_Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_Model& default_instance();

  void Swap(ModelInfo_Model* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_Model* New() const { return New(NULL); }

  ModelInfo_Model* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_Model& from);
  void MergeFrom(const ModelInfo_Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 2;
  const ::robotics::gazebotransport::ModelInfo_LINKS& links() const;
  ::robotics::gazebotransport::ModelInfo_LINKS* mutable_links();
  ::robotics::gazebotransport::ModelInfo_LINKS* release_links();
  void set_allocated_links(::robotics::gazebotransport::ModelInfo_LINKS* links);

  // optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 3;
  const ::robotics::gazebotransport::ModelInfo_JOINTS& joints() const;
  ::robotics::gazebotransport::ModelInfo_JOINTS* mutable_joints();
  ::robotics::gazebotransport::ModelInfo_JOINTS* release_joints();
  void set_allocated_joints(::robotics::gazebotransport::ModelInfo_JOINTS* joints);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ModelInfo.Model)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_links();
  inline void clear_has_links();
  inline void set_has_joints();
  inline void clear_has_joints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::robotics::gazebotransport::ModelInfo_LINKS* links_;
  ::robotics::gazebotransport::ModelInfo_JOINTS* joints_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_Model* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  void Swap(ModelInfo* other);

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const { return New(NULL); }

  ModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ModelInfo_LINKS LINKS;
  typedef ModelInfo_JOINTS JOINTS;
  typedef ModelInfo_Model Model;

  // accessors -------------------------------------------------------

  // repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
  int model_data_size() const;
  void clear_model_data();
  static const int kModelDataFieldNumber = 1;
  const ::robotics::gazebotransport::ModelInfo_Model& model_data(int index) const;
  ::robotics::gazebotransport::ModelInfo_Model* mutable_model_data(int index);
  ::robotics::gazebotransport::ModelInfo_Model* add_model_data();
  ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >*
      mutable_model_data();
  const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >&
      model_data() const;

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.ModelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model > model_data_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class MaxStepSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robotics.gazebotransport.MaxStepSize) */ {
 public:
  MaxStepSize();
  virtual ~MaxStepSize();

  MaxStepSize(const MaxStepSize& from);

  inline MaxStepSize& operator=(const MaxStepSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxStepSize& default_instance();

  void Swap(MaxStepSize* other);

  // implements Message ----------------------------------------------

  inline MaxStepSize* New() const { return New(NULL); }

  MaxStepSize* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaxStepSize& from);
  void MergeFrom(const MaxStepSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MaxStepSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MaxStepSize_TYPE TYPE;
  static const TYPE SET_STEP_SIZE =
    MaxStepSize_TYPE_SET_STEP_SIZE;
  static const TYPE GET_STEP_SIZE =
    MaxStepSize_TYPE_GET_STEP_SIZE;
  static inline bool TYPE_IsValid(int value) {
    return MaxStepSize_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    MaxStepSize_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    MaxStepSize_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    MaxStepSize_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return MaxStepSize_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return MaxStepSize_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return MaxStepSize_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::robotics::gazebotransport::MaxStepSize_TYPE type() const;
  void set_type(::robotics::gazebotransport::MaxStepSize_TYPE value);

  // required double size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  double size() const;
  void set_size(double value);

  // @@protoc_insertion_point(class_scope:robotics.gazebotransport.MaxStepSize)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double size_;
  int type_;
  friend void  protobuf_AddDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_robotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_robotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static MaxStepSize* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Time

// required uint64 seconds = 1;
inline bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Time.seconds)
  return seconds_;
}
inline void Time::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
inline bool Time::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
inline ::google::protobuf::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Time.nano_seconds)
  return nano_seconds_;
}
inline void Time::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Time.nano_seconds)
}

// -------------------------------------------------------------------

// PacketHeader

// required .robotics.gazebotransport.PacketHeader.MsgID id = 1;
inline bool PacketHeader::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketHeader::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketHeader::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.PacketHeader.id)
  return static_cast< ::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
inline void PacketHeader::set_id(::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.PacketHeader.id)
}

// required .robotics.gazebotransport.Time time_stamp = 2;
inline bool PacketHeader::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketHeader::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketHeader::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != NULL) time_stamp_->::robotics::gazebotransport::Time::Clear();
  clear_has_time_stamp();
}
inline const ::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_ != NULL ? *time_stamp_ : *default_instance_->time_stamp_;
}
inline ::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == NULL) {
    time_stamp_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_;
}
inline ::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.PacketHeader.time_stamp)
  clear_has_time_stamp();
  ::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
inline void PacketHeader::set_allocated_time_stamp(::robotics::gazebotransport::Time* time_stamp) {
  delete time_stamp_;
  time_stamp_ = time_stamp;
  if (time_stamp) {
    set_has_time_stamp();
  } else {
    clear_has_time_stamp();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.PacketHeader.time_stamp)
}

// -------------------------------------------------------------------

// Packet

// required .robotics.gazebotransport.PacketHeader header = 1;
inline bool Packet::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_header() {
  if (header_ != NULL) header_->::robotics::gazebotransport::PacketHeader::Clear();
  clear_has_header();
}
inline const ::robotics::gazebotransport::PacketHeader& Packet::header() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::robotics::gazebotransport::PacketHeader;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.header)
  return header_;
}
inline ::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.header)
  clear_has_header();
  ::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Packet::set_allocated_header(::robotics::gazebotransport::PacketHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.header)
}

// optional .robotics.gazebotransport.Packet.CoSimError status = 2;
inline bool Packet::has_status() const {
  return payload_case() == kStatus;
}
inline void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Packet::clear_status() {
  if (has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
inline ::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.status)
  if (has_status()) {
    return static_cast< ::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::robotics::gazebotransport::Packet_CoSimError >(0);
}
inline void Packet::set_status(::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Packet.status)
}

// optional .robotics.gazebotransport.StepSimulation step_simulation = 3;
inline bool Packet::has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
inline void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
inline void Packet::clear_step_simulation() {
  if (has_step_simulation()) {
    delete payload_.step_simulation_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.step_simulation)
  return has_step_simulation()
      ? *payload_.step_simulation_
      : ::robotics::gazebotransport::StepSimulation::default_instance();
}
inline ::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  if (!has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = new ::robotics::gazebotransport::StepSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.step_simulation)
  return payload_.step_simulation_;
}
inline ::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.step_simulation)
  if (has_step_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_step_simulation(::robotics::gazebotransport::StepSimulation* step_simulation) {
  clear_payload();
  if (step_simulation) {
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.step_simulation)
}

// optional .robotics.gazebotransport.ResetSimulation reset_simulation = 4;
inline bool Packet::has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
inline void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
inline void Packet::clear_reset_simulation() {
  if (has_reset_simulation()) {
    delete payload_.reset_simulation_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.reset_simulation)
  return has_reset_simulation()
      ? *payload_.reset_simulation_
      : ::robotics::gazebotransport::ResetSimulation::default_instance();
}
inline ::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  if (!has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = new ::robotics::gazebotransport::ResetSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.reset_simulation)
  return payload_.reset_simulation_;
}
inline ::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.reset_simulation)
  if (has_reset_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_reset_simulation(::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  clear_payload();
  if (reset_simulation) {
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.reset_simulation)
}

// optional .robotics.gazebotransport.Image image = 5;
inline bool Packet::has_image() const {
  return payload_case() == kImage;
}
inline void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Packet::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.image)
  return has_image()
      ? *payload_.image_
      : ::robotics::gazebotransport::Image::default_instance();
}
inline ::robotics::gazebotransport::Image* Packet::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = new ::robotics::gazebotransport::Image;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.image)
  return payload_.image_;
}
inline ::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.image)
  if (has_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_image(::robotics::gazebotransport::Image* image) {
  clear_payload();
  if (image) {
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.image)
}

// optional .robotics.gazebotransport.RequestImage request_image = 6;
inline bool Packet::has_request_image() const {
  return payload_case() == kRequestImage;
}
inline void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
inline void Packet::clear_request_image() {
  if (has_request_image()) {
    delete payload_.request_image_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_image)
  return has_request_image()
      ? *payload_.request_image_
      : ::robotics::gazebotransport::RequestImage::default_instance();
}
inline ::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  if (!has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = new ::robotics::gazebotransport::RequestImage;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_image)
  return payload_.request_image_;
}
inline ::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_image)
  if (has_request_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_image(::robotics::gazebotransport::RequestImage* request_image) {
  clear_payload();
  if (request_image) {
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_image)
}

// optional .robotics.gazebotransport.RequestCoSim request_cosim = 7;
inline bool Packet::has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
inline void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
inline void Packet::clear_request_cosim() {
  if (has_request_cosim()) {
    delete payload_.request_cosim_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_cosim)
  return has_request_cosim()
      ? *payload_.request_cosim_
      : ::robotics::gazebotransport::RequestCoSim::default_instance();
}
inline ::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  if (!has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = new ::robotics::gazebotransport::RequestCoSim;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_cosim)
  return payload_.request_cosim_;
}
inline ::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_cosim)
  if (has_request_cosim()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_cosim(::robotics::gazebotransport::RequestCoSim* request_cosim) {
  clear_payload();
  if (request_cosim) {
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_cosim)
}

// optional .robotics.gazebotransport.StopCoSim stop_cosim = 8;
inline bool Packet::has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
inline void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
inline void Packet::clear_stop_cosim() {
  if (has_stop_cosim()) {
    delete payload_.stop_cosim_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.stop_cosim)
  return has_stop_cosim()
      ? *payload_.stop_cosim_
      : ::robotics::gazebotransport::StopCoSim::default_instance();
}
inline ::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  if (!has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = new ::robotics::gazebotransport::StopCoSim;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.stop_cosim)
  return payload_.stop_cosim_;
}
inline ::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.stop_cosim)
  if (has_stop_cosim()) {
    clear_has_payload();
    ::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_stop_cosim(::robotics::gazebotransport::StopCoSim* stop_cosim) {
  clear_payload();
  if (stop_cosim) {
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.stop_cosim)
}

// optional .robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
inline bool Packet::has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
inline void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
inline void Packet::clear_get_ground_truth_world_pose() {
  if (has_get_ground_truth_world_pose()) {
    delete payload_.get_ground_truth_world_pose_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : ::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance();
}
inline ::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  if (!has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = new ::robotics::gazebotransport::GetGroundTruthWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return payload_.get_ground_truth_world_pose_;
}
inline ::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (has_get_ground_truth_world_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_ground_truth_world_pose(::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  clear_payload();
  if (get_ground_truth_world_pose) {
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}

// optional .robotics.gazebotransport.Pose pose = 10;
inline bool Packet::has_pose() const {
  return payload_case() == kPose;
}
inline void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void Packet::clear_pose() {
  if (has_pose()) {
    delete payload_.pose_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.pose)
  return has_pose()
      ? *payload_.pose_
      : ::robotics::gazebotransport::Pose::default_instance();
}
inline ::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  if (!has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = new ::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.pose)
  return payload_.pose_;
}
inline ::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.pose)
  if (has_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_pose(::robotics::gazebotransport::Pose* pose) {
  clear_payload();
  if (pose) {
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.pose)
}

// optional .robotics.gazebotransport.StopSimulation stop_simulation = 11;
inline bool Packet::has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
inline void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
inline void Packet::clear_stop_simulation() {
  if (has_stop_simulation()) {
    delete payload_.stop_simulation_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.stop_simulation)
  return has_stop_simulation()
      ? *payload_.stop_simulation_
      : ::robotics::gazebotransport::StopSimulation::default_instance();
}
inline ::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  if (!has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = new ::robotics::gazebotransport::StopSimulation;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.stop_simulation)
  return payload_.stop_simulation_;
}
inline ::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.stop_simulation)
  if (has_stop_simulation()) {
    clear_has_payload();
    ::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_stop_simulation(::robotics::gazebotransport::StopSimulation* stop_simulation) {
  clear_payload();
  if (stop_simulation) {
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.stop_simulation)
}

// optional .robotics.gazebotransport.LaserData laser_data = 12;
inline bool Packet::has_laser_data() const {
  return payload_case() == kLaserData;
}
inline void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
inline void Packet::clear_laser_data() {
  if (has_laser_data()) {
    delete payload_.laser_data_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.laser_data)
  return has_laser_data()
      ? *payload_.laser_data_
      : ::robotics::gazebotransport::LaserData::default_instance();
}
inline ::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  if (!has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = new ::robotics::gazebotransport::LaserData;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.laser_data)
  return payload_.laser_data_;
}
inline ::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.laser_data)
  if (has_laser_data()) {
    clear_has_payload();
    ::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_laser_data(::robotics::gazebotransport::LaserData* laser_data) {
  clear_payload();
  if (laser_data) {
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.laser_data)
}

// optional .robotics.gazebotransport.RequestLaser request_laser = 13;
inline bool Packet::has_request_laser() const {
  return payload_case() == kRequestLaser;
}
inline void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
inline void Packet::clear_request_laser() {
  if (has_request_laser()) {
    delete payload_.request_laser_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_laser)
  return has_request_laser()
      ? *payload_.request_laser_
      : ::robotics::gazebotransport::RequestLaser::default_instance();
}
inline ::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  if (!has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = new ::robotics::gazebotransport::RequestLaser;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_laser)
  return payload_.request_laser_;
}
inline ::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_laser)
  if (has_request_laser()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_laser(::robotics::gazebotransport::RequestLaser* request_laser) {
  clear_payload();
  if (request_laser) {
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_laser)
}

// optional .robotics.gazebotransport.ImuData imu_data = 14;
inline bool Packet::has_imu_data() const {
  return payload_case() == kImuData;
}
inline void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void Packet::clear_imu_data() {
  if (has_imu_data()) {
    delete payload_.imu_data_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.imu_data)
  return has_imu_data()
      ? *payload_.imu_data_
      : ::robotics::gazebotransport::ImuData::default_instance();
}
inline ::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = new ::robotics::gazebotransport::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.imu_data)
  return payload_.imu_data_;
}
inline ::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.imu_data)
  if (has_imu_data()) {
    clear_has_payload();
    ::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_imu_data(::robotics::gazebotransport::ImuData* imu_data) {
  clear_payload();
  if (imu_data) {
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.imu_data)
}

// optional .robotics.gazebotransport.RequestImu request_imu = 15;
inline bool Packet::has_request_imu() const {
  return payload_case() == kRequestImu;
}
inline void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
inline void Packet::clear_request_imu() {
  if (has_request_imu()) {
    delete payload_.request_imu_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.request_imu)
  return has_request_imu()
      ? *payload_.request_imu_
      : ::robotics::gazebotransport::RequestImu::default_instance();
}
inline ::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  if (!has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = new ::robotics::gazebotransport::RequestImu;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.request_imu)
  return payload_.request_imu_;
}
inline ::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.request_imu)
  if (has_request_imu()) {
    clear_has_payload();
    ::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_imu(::robotics::gazebotransport::RequestImu* request_imu) {
  clear_payload();
  if (request_imu) {
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.request_imu)
}

// optional .robotics.gazebotransport.SubscribeImage subscribe_image = 16;
inline bool Packet::has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
inline void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
inline void Packet::clear_subscribe_image() {
  if (has_subscribe_image()) {
    delete payload_.subscribe_image_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_image)
  return has_subscribe_image()
      ? *payload_.subscribe_image_
      : ::robotics::gazebotransport::SubscribeImage::default_instance();
}
inline ::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  if (!has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = new ::robotics::gazebotransport::SubscribeImage;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_image)
  return payload_.subscribe_image_;
}
inline ::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_image)
  if (has_subscribe_image()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_image(::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  clear_payload();
  if (subscribe_image) {
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_image)
}

// optional .robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
inline bool Packet::has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
inline void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
inline void Packet::clear_subscribe_laser() {
  if (has_subscribe_laser()) {
    delete payload_.subscribe_laser_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_laser)
  return has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : ::robotics::gazebotransport::SubscribeLaser::default_instance();
}
inline ::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  if (!has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = new ::robotics::gazebotransport::SubscribeLaser;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_laser)
  return payload_.subscribe_laser_;
}
inline ::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_laser)
  if (has_subscribe_laser()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_laser(::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  clear_payload();
  if (subscribe_laser) {
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_laser)
}

// optional .robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
inline bool Packet::has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
inline void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
inline void Packet::clear_subscribe_imu() {
  if (has_subscribe_imu()) {
    delete payload_.subscribe_imu_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.subscribe_imu)
  return has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : ::robotics::gazebotransport::SubscribeImu::default_instance();
}
inline ::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  if (!has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = new ::robotics::gazebotransport::SubscribeImu;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.subscribe_imu)
  return payload_.subscribe_imu_;
}
inline ::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.subscribe_imu)
  if (has_subscribe_imu()) {
    clear_has_payload();
    ::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_imu(::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  clear_payload();
  if (subscribe_imu) {
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.subscribe_imu)
}

// optional .robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
inline bool Packet::has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
inline void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
inline void Packet::clear_apply_joint_torque() {
  if (has_apply_joint_torque()) {
    delete payload_.apply_joint_torque_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.apply_joint_torque)
  return has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : ::robotics::gazebotransport::ApplyJointTorque::default_instance();
}
inline ::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  if (!has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = new ::robotics::gazebotransport::ApplyJointTorque;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.apply_joint_torque)
  return payload_.apply_joint_torque_;
}
inline ::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.apply_joint_torque)
  if (has_apply_joint_torque()) {
    clear_has_payload();
    ::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_apply_joint_torque(::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  clear_payload();
  if (apply_joint_torque) {
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.apply_joint_torque)
}

// optional .robotics.gazebotransport.GetPose get_pose = 20;
inline bool Packet::has_get_pose() const {
  return payload_case() == kGetPose;
}
inline void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
inline void Packet::clear_get_pose() {
  if (has_get_pose()) {
    delete payload_.get_pose_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_pose)
  return has_get_pose()
      ? *payload_.get_pose_
      : ::robotics::gazebotransport::GetPose::default_instance();
}
inline ::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  if (!has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = new ::robotics::gazebotransport::GetPose;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_pose)
  return payload_.get_pose_;
}
inline ::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_pose)
  if (has_get_pose()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_pose(::robotics::gazebotransport::GetPose* get_pose) {
  clear_payload();
  if (get_pose) {
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_pose)
}

// optional .robotics.gazebotransport.GetTopicList get_topic_list = 21;
inline bool Packet::has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
inline void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
inline void Packet::clear_get_topic_list() {
  if (has_get_topic_list()) {
    delete payload_.get_topic_list_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_topic_list)
  return has_get_topic_list()
      ? *payload_.get_topic_list_
      : ::robotics::gazebotransport::GetTopicList::default_instance();
}
inline ::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  if (!has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = new ::robotics::gazebotransport::GetTopicList;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_topic_list)
  return payload_.get_topic_list_;
}
inline ::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_topic_list)
  if (has_get_topic_list()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_topic_list(::robotics::gazebotransport::GetTopicList* get_topic_list) {
  clear_payload();
  if (get_topic_list) {
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_topic_list)
}

// optional .robotics.gazebotransport.TopicList topic_list = 22;
inline bool Packet::has_topic_list() const {
  return payload_case() == kTopicList;
}
inline void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
inline void Packet::clear_topic_list() {
  if (has_topic_list()) {
    delete payload_.topic_list_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.topic_list)
  return has_topic_list()
      ? *payload_.topic_list_
      : ::robotics::gazebotransport::TopicList::default_instance();
}
inline ::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  if (!has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = new ::robotics::gazebotransport::TopicList;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.topic_list)
  return payload_.topic_list_;
}
inline ::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.topic_list)
  if (has_topic_list()) {
    clear_has_payload();
    ::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_topic_list(::robotics::gazebotransport::TopicList* topic_list) {
  clear_payload();
  if (topic_list) {
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.topic_list)
}

// optional .robotics.gazebotransport.GetModelInfo get_model_info = 23;
inline bool Packet::has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
inline void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
inline void Packet::clear_get_model_info() {
  if (has_get_model_info()) {
    delete payload_.get_model_info_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.get_model_info)
  return has_get_model_info()
      ? *payload_.get_model_info_
      : ::robotics::gazebotransport::GetModelInfo::default_instance();
}
inline ::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  if (!has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = new ::robotics::gazebotransport::GetModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.get_model_info)
  return payload_.get_model_info_;
}
inline ::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.get_model_info)
  if (has_get_model_info()) {
    clear_has_payload();
    ::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_model_info(::robotics::gazebotransport::GetModelInfo* get_model_info) {
  clear_payload();
  if (get_model_info) {
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.get_model_info)
}

// optional .robotics.gazebotransport.ModelInfo model_info = 24;
inline bool Packet::has_model_info() const {
  return payload_case() == kModelInfo;
}
inline void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
inline void Packet::clear_model_info() {
  if (has_model_info()) {
    delete payload_.model_info_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.model_info)
  return has_model_info()
      ? *payload_.model_info_
      : ::robotics::gazebotransport::ModelInfo::default_instance();
}
inline ::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  if (!has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = new ::robotics::gazebotransport::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.model_info)
  return payload_.model_info_;
}
inline ::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.model_info)
  if (has_model_info()) {
    clear_has_payload();
    ::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_model_info(::robotics::gazebotransport::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.model_info)
}

// optional .robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
inline bool Packet::has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
inline void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
inline void Packet::clear_apply_link_wrench() {
  if (has_apply_link_wrench()) {
    delete payload_.apply_link_wrench_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.apply_link_wrench)
  return has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : ::robotics::gazebotransport::ApplyLinkWrench::default_instance();
}
inline ::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  if (!has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = new ::robotics::gazebotransport::ApplyLinkWrench;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.apply_link_wrench)
  return payload_.apply_link_wrench_;
}
inline ::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.apply_link_wrench)
  if (has_apply_link_wrench()) {
    clear_has_payload();
    ::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_apply_link_wrench(::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  clear_payload();
  if (apply_link_wrench) {
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.apply_link_wrench)
}

// optional .robotics.gazebotransport.MaxStepSize max_step_size = 26;
inline bool Packet::has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
inline void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
inline void Packet::clear_max_step_size() {
  if (has_max_step_size()) {
    delete payload_.max_step_size_;
    clear_has_payload();
  }
}
inline  const ::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Packet.max_step_size)
  return has_max_step_size()
      ? *payload_.max_step_size_
      : ::robotics::gazebotransport::MaxStepSize::default_instance();
}
inline ::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  if (!has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = new ::robotics::gazebotransport::MaxStepSize;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Packet.max_step_size)
  return payload_.max_step_size_;
}
inline ::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Packet.max_step_size)
  if (has_max_step_size()) {
    clear_has_payload();
    ::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_max_step_size(::robotics::gazebotransport::MaxStepSize* max_step_size) {
  clear_payload();
  if (max_step_size) {
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Packet.max_step_size)
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StepSimulation

// required uint32 num_steps = 1;
inline bool StepSimulation::has_num_steps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepSimulation::set_has_num_steps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepSimulation::clear_has_num_steps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  clear_has_num_steps();
}
inline ::google::protobuf::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StepSimulation.num_steps)
  return num_steps_;
}
inline void StepSimulation::set_num_steps(::google::protobuf::uint32 value) {
  set_has_num_steps();
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StepSimulation.num_steps)
}

// -------------------------------------------------------------------

// ResetSimulation

// required .robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
inline bool ResetSimulation::has_behavior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetSimulation::set_has_behavior() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetSimulation::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  clear_has_behavior();
}
inline ::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ResetSimulation.behavior)
  return static_cast< ::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
inline void ResetSimulation::set_behavior(::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  set_has_behavior();
  behavior_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ResetSimulation.behavior)
}

// -------------------------------------------------------------------

// Image

// required uint32 width = 1;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.width)
}

// required uint32 height = 2;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.height)
}

// required bytes data = 3;
inline bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.Image.data)
}
inline ::std::string* Image::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Image.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Image.data)
}

// required string data_type = 4;
inline bool Image::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
inline const ::std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Image.data_type)
  return data_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.Image.data_type)
}
inline ::std::string* Image::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Image.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Image.data_type)
  clear_has_data_type();
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Image.data_type)
}

// -------------------------------------------------------------------

// RequestImage

// required string topic_name = 1;
inline bool RequestImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestImage.topic_name)
}
inline ::std::string* RequestImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestImage.topic_name)
}

// -------------------------------------------------------------------

// RequestCoSim

// required string client_id = 1;
inline bool RequestCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestCoSim.client_id)
}
inline ::std::string* RequestCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
inline bool RequestCoSim::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCoSim::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCoSim::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCoSim::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestCoSim.duration)
  return duration_;
}
inline void RequestCoSim::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestCoSim.duration)
}

// -------------------------------------------------------------------

// StopCoSim

// required string client_id = 1;
inline bool StopCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.StopCoSim.client_id)
}
inline ::std::string* StopCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.StopCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.StopCoSim.client_id)
}

// -------------------------------------------------------------------

// GetGroundTruthWorldPose

// required string model_name = 1;
inline bool GetGroundTruthWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
inline bool GetGroundTruthWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.y)
}

// required double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// required double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.Quaternion.w)
}

// -------------------------------------------------------------------

// Pose

// required .robotics.gazebotransport.Point position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::robotics::gazebotransport::Point::Clear();
  clear_has_position();
}
inline const ::robotics::gazebotransport::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::robotics::gazebotransport::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Pose.position)
  return position_;
}
inline ::robotics::gazebotransport::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Pose.position)
  clear_has_position();
  ::robotics::gazebotransport::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::robotics::gazebotransport::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Pose.position)
}

// required .robotics.gazebotransport.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.Pose.orientation)
  return orientation_;
}
inline ::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.Pose.orientation)
  clear_has_orientation();
  ::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.Pose.orientation)
}

// -------------------------------------------------------------------

// StopSimulation

// required bool stop_scene = 1;
inline bool StopSimulation::has_stop_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSimulation::set_has_stop_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSimulation::clear_has_stop_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  clear_has_stop_scene();
}
inline bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.StopSimulation.stop_scene)
  return stop_scene_;
}
inline void StopSimulation::set_stop_scene(bool value) {
  set_has_stop_scene();
  stop_scene_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.StopSimulation.stop_scene)
}

// -------------------------------------------------------------------

// LaserData

// required double angle_min = 1;
inline bool LaserData::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaserData::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaserData::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaserData::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_min)
  return angle_min_;
}
inline void LaserData::set_angle_min(double value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_min)
}

// required double angle_max = 2;
inline bool LaserData::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserData::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserData::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserData::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_max)
  return angle_max_;
}
inline void LaserData::set_angle_max(double value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_max)
}

// required double angle_step = 3;
inline bool LaserData::has_angle_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaserData::set_has_angle_step() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaserData::clear_has_angle_step() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaserData::clear_angle_step() {
  angle_step_ = 0;
  clear_has_angle_step();
}
inline double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.angle_step)
  return angle_step_;
}
inline void LaserData::set_angle_step(double value) {
  set_has_angle_step();
  angle_step_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.angle_step)
}

// required double range_min = 4;
inline bool LaserData::has_range_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaserData::set_has_range_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaserData::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaserData::clear_range_min() {
  range_min_ = 0;
  clear_has_range_min();
}
inline double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range_min)
  return range_min_;
}
inline void LaserData::set_range_min(double value) {
  set_has_range_min();
  range_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range_min)
}

// required double range_max = 5;
inline bool LaserData::has_range_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaserData::set_has_range_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaserData::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaserData::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range_max)
  return range_max_;
}
inline void LaserData::set_range_max(double value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range_max)
}

// required double count = 6;
inline bool LaserData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaserData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaserData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaserData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double LaserData::count() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.count)
  return count_;
}
inline void LaserData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.count)
}

// required double vertical_angle_min = 7;
inline bool LaserData::has_vertical_angle_min() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaserData::set_has_vertical_angle_min() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaserData::clear_has_vertical_angle_min() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  clear_has_vertical_angle_min();
}
inline double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_min)
  return vertical_angle_min_;
}
inline void LaserData::set_vertical_angle_min(double value) {
  set_has_vertical_angle_min();
  vertical_angle_min_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_min)
}

// required double vertical_angle_max = 8;
inline bool LaserData::has_vertical_angle_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaserData::set_has_vertical_angle_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaserData::clear_has_vertical_angle_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  clear_has_vertical_angle_max();
}
inline double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_max)
  return vertical_angle_max_;
}
inline void LaserData::set_vertical_angle_max(double value) {
  set_has_vertical_angle_max();
  vertical_angle_max_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_max)
}

// required double vertical_angle_step = 9;
inline bool LaserData::has_vertical_angle_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LaserData::set_has_vertical_angle_step() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LaserData::clear_has_vertical_angle_step() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  clear_has_vertical_angle_step();
}
inline double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.vertical_angle_step)
  return vertical_angle_step_;
}
inline void LaserData::set_vertical_angle_step(double value) {
  set_has_vertical_angle_step();
  vertical_angle_step_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
inline int LaserData::range_size() const {
  return range_.size();
}
inline void LaserData::clear_range() {
  range_.Clear();
}
inline double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.range)
  return range_.Get(index);
}
inline void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.range)
}
inline void LaserData::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.LaserData.range)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.LaserData.range)
  return range_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.LaserData.range)
  return &range_;
}

// repeated double intensities = 11;
inline int LaserData::intensities_size() const {
  return intensities_.size();
}
inline void LaserData::clear_intensities() {
  intensities_.Clear();
}
inline double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.LaserData.intensities)
  return intensities_.Get(index);
}
inline void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.LaserData.intensities)
}
inline void LaserData::add_intensities(double value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.LaserData.intensities)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.LaserData.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.LaserData.intensities)
  return &intensities_;
}

// -------------------------------------------------------------------

// RequestLaser

// required string topic_name = 1;
inline bool RequestLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestLaser.topic_name)
}
inline ::std::string* RequestLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestLaser.topic_name)
}

// -------------------------------------------------------------------

// ImuData

// required .robotics.gazebotransport.Point linear_acceleration = 1;
inline bool ImuData::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImuData::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImuData::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::robotics::gazebotransport::Point::Clear();
  clear_has_linear_acceleration();
}
inline const ::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
inline ::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_;
}
inline ::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.linear_acceleration)
  clear_has_linear_acceleration();
  ::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_linear_acceleration(::robotics::gazebotransport::Point* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.linear_acceleration)
}

// required .robotics.gazebotransport.Point angular_velocity = 2;
inline bool ImuData::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImuData::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImuData::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::robotics::gazebotransport::Point::Clear();
  clear_has_angular_velocity();
}
inline const ::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_;
}
inline ::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.angular_velocity)
  clear_has_angular_velocity();
  ::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_angular_velocity(::robotics::gazebotransport::Point* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.angular_velocity)
}

// required .robotics.gazebotransport.Quaternion orientation = 3;
inline bool ImuData::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImuData::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImuData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImuData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ImuData.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ImuData.orientation)
  return orientation_;
}
inline ::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ImuData.orientation)
  clear_has_orientation();
  ::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_orientation(::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ImuData.orientation)
}

// -------------------------------------------------------------------

// RequestImu

// required string topic_name = 1;
inline bool RequestImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.RequestImu.topic_name)
}
inline ::std::string* RequestImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.RequestImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.RequestImu.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImage

// required string topic_name = 1;
inline bool SubscribeImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeImage.topic_name)
}
inline ::std::string* SubscribeImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeImage.topic_name)
}

// -------------------------------------------------------------------

// SubscribeLaser

// required string topic_name = 1;
inline bool SubscribeLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline ::std::string* SubscribeLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeLaser.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImu

// required string topic_name = 1;
inline bool SubscribeImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.SubscribeImu.topic_name)
}
inline ::std::string* SubscribeImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.SubscribeImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.SubscribeImu.topic_name)
}

// -------------------------------------------------------------------

// ApplyLinkWrench

// required string model_name = 1;
inline bool ApplyLinkWrench::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyLinkWrench::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyLinkWrench::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline ::std::string* ApplyLinkWrench::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
inline bool ApplyLinkWrench::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyLinkWrench::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyLinkWrench::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline ::std::string* ApplyLinkWrench::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
inline bool ApplyLinkWrench::has_force_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyLinkWrench::set_has_force_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyLinkWrench::clear_has_force_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_force_type();
}
inline const ::std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_force_type(const ::std::string& value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value, size_t size) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline ::std::string* ApplyLinkWrench::mutable_force_type() {
  set_has_force_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.force_type)
  clear_has_force_type();
  return force_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_force_type(::std::string* force_type) {
  if (force_type != NULL) {
    set_has_force_type();
  } else {
    clear_has_force_type();
  }
  force_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), force_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
inline bool ApplyLinkWrench::has_fx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyLinkWrench::set_has_fx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyLinkWrench::clear_has_fx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  clear_has_fx();
}
inline double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fx)
  return fx_;
}
inline void ApplyLinkWrench::set_fx(double value) {
  set_has_fx();
  fx_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
inline bool ApplyLinkWrench::has_fy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyLinkWrench::set_has_fy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyLinkWrench::clear_has_fy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  clear_has_fy();
}
inline double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fy)
  return fy_;
}
inline void ApplyLinkWrench::set_fy(double value) {
  set_has_fy();
  fy_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
inline bool ApplyLinkWrench::has_fz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplyLinkWrench::set_has_fz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplyLinkWrench::clear_has_fz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  clear_has_fz();
}
inline double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.fz)
  return fz_;
}
inline void ApplyLinkWrench::set_fz(double value) {
  set_has_fz();
  fz_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
inline bool ApplyLinkWrench::has_torque_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApplyLinkWrench::set_has_torque_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ApplyLinkWrench::clear_has_torque_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_torque_type();
}
inline const ::std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_torque_type(const ::std::string& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value, size_t size) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline ::std::string* ApplyLinkWrench::mutable_torque_type() {
  set_has_torque_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.torque_type)
  clear_has_torque_type();
  return torque_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_torque_type(::std::string* torque_type) {
  if (torque_type != NULL) {
    set_has_torque_type();
  } else {
    clear_has_torque_type();
  }
  torque_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), torque_type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
inline bool ApplyLinkWrench::has_tx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ApplyLinkWrench::set_has_tx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ApplyLinkWrench::clear_has_tx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.tx)
  return tx_;
}
inline void ApplyLinkWrench::set_tx(double value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
inline bool ApplyLinkWrench::has_ty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ApplyLinkWrench::set_has_ty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ApplyLinkWrench::clear_has_ty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.ty)
  return ty_;
}
inline void ApplyLinkWrench::set_ty(double value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
inline bool ApplyLinkWrench::has_tz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ApplyLinkWrench::set_has_tz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ApplyLinkWrench::clear_has_tz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
inline double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.tz)
  return tz_;
}
inline void ApplyLinkWrench::set_tz(double value) {
  set_has_tz();
  tz_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .robotics.gazebotransport.Time duration = 11;
inline bool ApplyLinkWrench::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ApplyLinkWrench::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ApplyLinkWrench::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ApplyLinkWrench::clear_duration() {
  if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_;
}
inline ::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyLinkWrench.duration)
  clear_has_duration();
  ::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void ApplyLinkWrench::set_allocated_duration(::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyLinkWrench.duration)
}

// -------------------------------------------------------------------

// ApplyJointTorque

// required string model_name = 1;
inline bool ApplyJointTorque::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyJointTorque::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyJointTorque::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline ::std::string* ApplyJointTorque::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
inline bool ApplyJointTorque::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyJointTorque::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyJointTorque::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline ::std::string* ApplyJointTorque::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
inline bool ApplyJointTorque::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyJointTorque::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyJointTorque::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyJointTorque::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.index)
  return index_;
}
inline void ApplyJointTorque::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
inline bool ApplyJointTorque::has_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyJointTorque::set_has_effort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyJointTorque::clear_has_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  clear_has_effort();
}
inline double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.effort)
  return effort_;
}
inline void ApplyJointTorque::set_effort(double value) {
  set_has_effort();
  effort_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .robotics.gazebotransport.Time duration = 5;
inline bool ApplyJointTorque::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyJointTorque::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyJointTorque::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyJointTorque::clear_duration() {
  if (duration_ != NULL) duration_->::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_;
}
inline ::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ApplyJointTorque.duration)
  clear_has_duration();
  ::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void ApplyJointTorque::set_allocated_duration(::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ApplyJointTorque.duration)
}

// -------------------------------------------------------------------

// GetPose

// required string model_name = 1;
inline bool GetPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetPose.model_name)
}
inline ::std::string* GetPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetPose.model_name)
}

// -------------------------------------------------------------------

// GetTopicList

// required string topic_name = 1;
inline bool GetTopicList::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTopicList::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTopicList::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTopicList::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetTopicList.topic_name)
}
inline ::std::string* GetTopicList::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetTopicList.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTopicList::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetTopicList.topic_name)
}

// -------------------------------------------------------------------

// TopicList_TopicInfo

// required string name = 1;
inline bool TopicList_TopicInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicList_TopicInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicList_TopicInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline ::std::string* TopicList_TopicInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.TopicList.TopicInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
inline bool TopicList_TopicInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicList_TopicInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicList_TopicInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline ::std::string* TopicList_TopicInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.TopicList.TopicInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .robotics.gazebotransport.TopicList.TopicInfo data = 1;
inline int TopicList::data_size() const {
  return data_.size();
}
inline void TopicList::clear_data() {
  data_.Clear();
}
inline const ::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.TopicList.data)
  return data_.Get(index);
}
inline ::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
inline ::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.TopicList.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.TopicList.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.TopicList.data)
  return data_;
}

// -------------------------------------------------------------------

// GetModelInfo

// required string topic_name = 1;
inline bool GetModelInfo::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetModelInfo::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetModelInfo::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModelInfo::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.GetModelInfo.topic_name)
}
inline ::std::string* GetModelInfo::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.GetModelInfo.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModelInfo::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.GetModelInfo.topic_name)
}

// -------------------------------------------------------------------

// ModelInfo_LINKS

// repeated string link_name = 1;
inline int ModelInfo_LINKS::link_name_size() const {
  return link_name_.size();
}
inline void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
inline const ::std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Get(index);
}
inline ::std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
inline void ModelInfo_LINKS::set_link_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline ::std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Add();
}
inline void ModelInfo_LINKS::add_link_name(const ::std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
inline int ModelInfo_JOINTS::joint_name_size() const {
  return joint_name_.size();
}
inline void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
inline const ::std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Get(index);
}
inline ::std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline ::std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Add();
}
inline void ModelInfo_JOINTS::add_joint_name(const ::std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
inline bool ModelInfo_Model::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo_Model::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo_Model::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo_Model::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline ::std::string* ModelInfo_Model::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo_Model::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .robotics.gazebotransport.ModelInfo.LINKS links = 2;
inline bool ModelInfo_Model::has_links() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo_Model::set_has_links() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo_Model::clear_has_links() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo_Model::clear_links() {
  if (links_ != NULL) links_->::robotics::gazebotransport::ModelInfo_LINKS::Clear();
  clear_has_links();
}
inline const ::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.links)
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
inline ::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::robotics::gazebotransport::ModelInfo_LINKS;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.links)
  return links_;
}
inline ::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.links)
  clear_has_links();
  ::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = NULL;
  return temp;
}
inline void ModelInfo_Model::set_allocated_links(::robotics::gazebotransport::ModelInfo_LINKS* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
inline bool ModelInfo_Model::has_joints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo_Model::set_has_joints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo_Model::clear_has_joints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo_Model::clear_joints() {
  if (joints_ != NULL) joints_->::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
  clear_has_joints();
}
inline const ::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
inline ::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::robotics::gazebotransport::ModelInfo_JOINTS;
  }
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_;
}
inline ::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  // @@protoc_insertion_point(field_release:robotics.gazebotransport.ModelInfo.Model.joints)
  clear_has_joints();
  ::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void ModelInfo_Model::set_allocated_joints(::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .robotics.gazebotransport.ModelInfo.Model model_data = 1;
inline int ModelInfo::model_data_size() const {
  return model_data_.size();
}
inline void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
inline const ::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Get(index);
}
inline ::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
inline ::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

// -------------------------------------------------------------------

// MaxStepSize

// required .robotics.gazebotransport.MaxStepSize.TYPE type = 1;
inline bool MaxStepSize::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaxStepSize::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaxStepSize::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaxStepSize::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.MaxStepSize.type)
  return static_cast< ::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
inline void MaxStepSize::set_type(::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
inline bool MaxStepSize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaxStepSize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaxStepSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaxStepSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:robotics.gazebotransport.MaxStepSize.size)
  return size_;
}
inline void MaxStepSize::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:robotics.gazebotransport.MaxStepSize.size)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::robotics::gazebotransport::PacketHeader_MsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robotics::gazebotransport::PacketHeader_MsgID>() {
  return ::robotics::gazebotransport::PacketHeader_MsgID_descriptor();
}
template <> struct is_proto_enum< ::robotics::gazebotransport::Packet_CoSimError> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robotics::gazebotransport::Packet_CoSimError>() {
  return ::robotics::gazebotransport::Packet_CoSimError_descriptor();
}
template <> struct is_proto_enum< ::robotics::gazebotransport::ResetSimulation_ResetBehavior> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robotics::gazebotransport::ResetSimulation_ResetBehavior>() {
  return ::robotics::gazebotransport::ResetSimulation_ResetBehavior_descriptor();
}
template <> struct is_proto_enum< ::robotics::gazebotransport::MaxStepSize_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robotics::gazebotransport::MaxStepSize_TYPE>() {
  return ::robotics::gazebotransport::MaxStepSize_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_robotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED
